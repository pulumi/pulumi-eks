// Code generated by pulumi-gen-eks DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/cloudformation"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/ec2"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/iam"
	"github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	storagev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/storage/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptions struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId *string `pulumi:"amiId"`
	// The AMI Type to use for the worker nodes.
	//
	// Only applicable when setting an AMI ID that is of type `arm64`.
	//
	// Note: `amiType` and `gpu` are mutually exclusive.
	AmiType *string `pulumi:"amiType"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags map[string]string `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs *string `pulumi:"bootstrapExtraArgs"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags map[string]string `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule *ec2.SecurityGroupRule `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity *int `pulumi:"desiredCapacity"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice *bool `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu *bool `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile *iam.InstanceProfile `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType *string `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName *string `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
	KubeletExtraArgs *string `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize *int `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize *int `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress *bool `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey *string `pulumi:"nodePublicKey"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize *int `pulumi:"nodeRootVolumeSize"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds []string `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData *string `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride *string `pulumi:"nodeUserDataOverride"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice *string `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints map[string]Taint `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version *string `pulumi:"version"`
}

// ClusterNodeGroupOptionsInput is an input type that accepts ClusterNodeGroupOptionsArgs and ClusterNodeGroupOptionsOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsInput` via:
//
//	ClusterNodeGroupOptionsArgs{...}
type ClusterNodeGroupOptionsInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput
	ToClusterNodeGroupOptionsOutputWithContext(context.Context) ClusterNodeGroupOptionsOutput
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsArgs struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId pulumi.StringPtrInput `pulumi:"amiId"`
	// The AMI Type to use for the worker nodes.
	//
	// Only applicable when setting an AMI ID that is of type `arm64`.
	//
	// Note: `amiType` and `gpu` are mutually exclusive.
	AmiType pulumi.StringPtrInput `pulumi:"amiType"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags pulumi.StringMapInput `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs *string `pulumi:"bootstrapExtraArgs"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags pulumi.StringMapInput `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule *ec2.SecurityGroupRule `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity pulumi.IntPtrInput `pulumi:"desiredCapacity"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice pulumi.BoolPtrInput `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu pulumi.BoolPtrInput `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile *iam.InstanceProfile `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
	KubeletExtraArgs *string `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize pulumi.IntPtrInput `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize pulumi.IntPtrInput `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress *bool `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey pulumi.StringPtrInput `pulumi:"nodePublicKey"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize pulumi.IntPtrInput `pulumi:"nodeRootVolumeSize"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds pulumi.StringArrayInput `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData pulumi.StringPtrInput `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride pulumi.StringPtrInput `pulumi:"nodeUserDataOverride"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice pulumi.StringPtrInput `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints map[string]TaintArgs `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ClusterNodeGroupOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return i.ToClusterNodeGroupOptionsOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput)
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput).ToClusterNodeGroupOptionsPtrOutputWithContext(ctx)
}

// ClusterNodeGroupOptionsPtrInput is an input type that accepts ClusterNodeGroupOptionsArgs, ClusterNodeGroupOptionsPtr and ClusterNodeGroupOptionsPtrOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsPtrInput` via:
//
//	        ClusterNodeGroupOptionsArgs{...}
//
//	or:
//
//	        nil
type ClusterNodeGroupOptionsPtrInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput
	ToClusterNodeGroupOptionsPtrOutputWithContext(context.Context) ClusterNodeGroupOptionsPtrOutput
}

type clusterNodeGroupOptionsPtrType ClusterNodeGroupOptionsArgs

func ClusterNodeGroupOptionsPtr(v *ClusterNodeGroupOptionsArgs) ClusterNodeGroupOptionsPtrInput {
	return (*clusterNodeGroupOptionsPtrType)(v)
}

func (*clusterNodeGroupOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsPtrOutput)
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterNodeGroupOptions) *ClusterNodeGroupOptions {
		return &v
	}).(ClusterNodeGroupOptionsPtrOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.AmiId }).(pulumi.StringPtrOutput)
}

// The AMI Type to use for the worker nodes.
//
// Only applicable when setting an AMI ID that is of type `arm64`.
//
// Note: `amiType` and `gpu` are mutually exclusive.
func (o ClusterNodeGroupOptionsOutput) AmiType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.AmiType }).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.AutoScalingGroupTags }).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.BootstrapExtraArgs }).(pulumi.StringPtrOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.CloudFormationTags }).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroupRule { return v.ClusterIngressRule }).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.DesiredCapacity }).(pulumi.IntPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.EncryptRootBlockDevice }).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.Gpu }).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *iam.InstanceProfile { return v.InstanceProfile }).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KubeletExtraArgs }).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MaxSize }).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MinSize }).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.NodeAssociatePublicIpAddress }).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodePublicKey }).(pulumi.StringPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.NodeRootVolumeSize }).(pulumi.IntPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []string { return v.NodeSubnetIds }).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserData }).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserDataOverride }).(pulumi.StringPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.SpotPrice }).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]Taint { return v.Taints }).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ClusterNodeGroupOptionsPtrOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) Elem() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) ClusterNodeGroupOptions {
		if v != nil {
			return *v
		}
		var ret ClusterNodeGroupOptions
		return ret
	}).(ClusterNodeGroupOptionsOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsPtrOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.AmiId
	}).(pulumi.StringPtrOutput)
}

// The AMI Type to use for the worker nodes.
//
// Only applicable when setting an AMI ID that is of type `arm64`.
//
// Note: `amiType` and `gpu` are mutually exclusive.
func (o ClusterNodeGroupOptionsPtrOutput) AmiType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.AmiType
	}).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.AutoScalingGroupTags
	}).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsPtrOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.BootstrapExtraArgs
	}).(pulumi.StringPtrOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.CloudFormationTags
	}).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroupRule {
		if v == nil {
			return nil
		}
		return v.ClusterIngressRule
	}).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.DesiredCapacity
	}).(pulumi.IntPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsPtrOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EncryptRootBlockDevice
	}).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsPtrOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.Gpu
	}).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *iam.InstanceProfile {
		if v == nil {
			return nil
		}
		return v.InstanceProfile
	}).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsPtrOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KubeletExtraArgs
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MinSize
	}).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsPtrOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodeAssociatePublicIpAddress
	}).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsPtrOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodePublicKey
	}).(pulumi.StringPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeSize
	}).(pulumi.IntPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []string {
		if v == nil {
			return nil
		}
		return v.NodeSubnetIds
	}).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserData
	}).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserDataOverride
	}).(pulumi.StringPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsPtrOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.SpotPrice
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsPtrOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]Taint {
		if v == nil {
			return nil
		}
		return v.Taints
	}).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreData struct {
	AwsProvider *aws.Provider `pulumi:"awsProvider"`
	Cluster     *eks.Cluster  `pulumi:"cluster"`
	// The IAM Role attached to the EKS Cluster
	ClusterIamRole        *iam.Role                          `pulumi:"clusterIamRole"`
	ClusterSecurityGroup  *ec2.SecurityGroup                 `pulumi:"clusterSecurityGroup"`
	EksNodeAccess         *corev1.ConfigMap                  `pulumi:"eksNodeAccess"`
	EncryptionConfig      *eks.ClusterEncryptionConfig       `pulumi:"encryptionConfig"`
	Endpoint              string                             `pulumi:"endpoint"`
	FargateProfile        *eks.FargateProfile                `pulumi:"fargateProfile"`
	InstanceRoles         []*iam.Role                        `pulumi:"instanceRoles"`
	Kubeconfig            interface{}                        `pulumi:"kubeconfig"`
	NodeGroupOptions      ClusterNodeGroupOptions            `pulumi:"nodeGroupOptions"`
	NodeSecurityGroupTags map[string]string                  `pulumi:"nodeSecurityGroupTags"`
	OidcProvider          *iam.OpenIdConnectProvider         `pulumi:"oidcProvider"`
	PrivateSubnetIds      []string                           `pulumi:"privateSubnetIds"`
	Provider              *kubernetes.Provider               `pulumi:"provider"`
	PublicSubnetIds       []string                           `pulumi:"publicSubnetIds"`
	StorageClasses        map[string]*storagev1.StorageClass `pulumi:"storageClasses"`
	SubnetIds             []string                           `pulumi:"subnetIds"`
	Tags                  map[string]string                  `pulumi:"tags"`
	VpcCni                *VpcCni                            `pulumi:"vpcCni"`
	VpcId                 string                             `pulumi:"vpcId"`
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreDataOutput struct{ *pulumi.OutputState }

func (CoreDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreData)(nil)).Elem()
}

func (o CoreDataOutput) ToCoreDataOutput() CoreDataOutput {
	return o
}

func (o CoreDataOutput) ToCoreDataOutputWithContext(ctx context.Context) CoreDataOutput {
	return o
}

func (o CoreDataOutput) AwsProvider() aws.ProviderOutput {
	return o.ApplyT(func(v CoreData) *aws.Provider { return v.AwsProvider }).(aws.ProviderOutput)
}

func (o CoreDataOutput) Cluster() eks.ClusterOutput {
	return o.ApplyT(func(v CoreData) *eks.Cluster { return v.Cluster }).(eks.ClusterOutput)
}

// The IAM Role attached to the EKS Cluster
func (o CoreDataOutput) ClusterIamRole() iam.RoleOutput {
	return o.ApplyT(func(v CoreData) *iam.Role { return v.ClusterIamRole }).(iam.RoleOutput)
}

func (o CoreDataOutput) ClusterSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v CoreData) *ec2.SecurityGroup { return v.ClusterSecurityGroup }).(ec2.SecurityGroupOutput)
}

func (o CoreDataOutput) EksNodeAccess() corev1.ConfigMapOutput {
	return o.ApplyT(func(v CoreData) *corev1.ConfigMap { return v.EksNodeAccess }).(corev1.ConfigMapOutput)
}

func (o CoreDataOutput) EncryptionConfig() eks.ClusterEncryptionConfigPtrOutput {
	return o.ApplyT(func(v CoreData) *eks.ClusterEncryptionConfig { return v.EncryptionConfig }).(eks.ClusterEncryptionConfigPtrOutput)
}

func (o CoreDataOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.Endpoint }).(pulumi.StringOutput)
}

func (o CoreDataOutput) FargateProfile() eks.FargateProfileOutput {
	return o.ApplyT(func(v CoreData) *eks.FargateProfile { return v.FargateProfile }).(eks.FargateProfileOutput)
}

func (o CoreDataOutput) InstanceRoles() iam.RoleArrayOutput {
	return o.ApplyT(func(v CoreData) []*iam.Role { return v.InstanceRoles }).(iam.RoleArrayOutput)
}

func (o CoreDataOutput) Kubeconfig() pulumi.AnyOutput {
	return o.ApplyT(func(v CoreData) interface{} { return v.Kubeconfig }).(pulumi.AnyOutput)
}

func (o CoreDataOutput) NodeGroupOptions() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v CoreData) ClusterNodeGroupOptions { return v.NodeGroupOptions }).(ClusterNodeGroupOptionsOutput)
}

func (o CoreDataOutput) NodeSecurityGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.NodeSecurityGroupTags }).(pulumi.StringMapOutput)
}

func (o CoreDataOutput) OidcProvider() iam.OpenIdConnectProviderOutput {
	return o.ApplyT(func(v CoreData) *iam.OpenIdConnectProvider { return v.OidcProvider }).(iam.OpenIdConnectProviderOutput)
}

func (o CoreDataOutput) PrivateSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PrivateSubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) Provider() kubernetes.ProviderOutput {
	return o.ApplyT(func(v CoreData) *kubernetes.Provider { return v.Provider }).(kubernetes.ProviderOutput)
}

func (o CoreDataOutput) PublicSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PublicSubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) StorageClasses() storagev1.StorageClassMapOutput {
	return o.ApplyT(func(v CoreData) map[string]*storagev1.StorageClass { return v.StorageClasses }).(storagev1.StorageClassMapOutput)
}

func (o CoreDataOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

func (o CoreDataOutput) VpcCni() VpcCniOutput {
	return o.ApplyT(func(v CoreData) *VpcCni { return v.VpcCni }).(VpcCniOutput)
}

func (o CoreDataOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.VpcId }).(pulumi.StringOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProvider struct {
	Provider *aws.Provider `pulumi:"provider"`
	Role     *iam.Role     `pulumi:"role"`
}

// CreationRoleProviderInput is an input type that accepts CreationRoleProviderArgs and CreationRoleProviderOutput values.
// You can construct a concrete instance of `CreationRoleProviderInput` via:
//
//	CreationRoleProviderArgs{...}
type CreationRoleProviderInput interface {
	pulumi.Input

	ToCreationRoleProviderOutput() CreationRoleProviderOutput
	ToCreationRoleProviderOutputWithContext(context.Context) CreationRoleProviderOutput
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProviderArgs struct {
	Provider *aws.Provider `pulumi:"provider"`
	Role     *iam.Role     `pulumi:"role"`
}

func (CreationRoleProviderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return i.ToCreationRoleProviderOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput)
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput).ToCreationRoleProviderPtrOutputWithContext(ctx)
}

// CreationRoleProviderPtrInput is an input type that accepts CreationRoleProviderArgs, CreationRoleProviderPtr and CreationRoleProviderPtrOutput values.
// You can construct a concrete instance of `CreationRoleProviderPtrInput` via:
//
//	        CreationRoleProviderArgs{...}
//
//	or:
//
//	        nil
type CreationRoleProviderPtrInput interface {
	pulumi.Input

	ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput
	ToCreationRoleProviderPtrOutputWithContext(context.Context) CreationRoleProviderPtrOutput
}

type creationRoleProviderPtrType CreationRoleProviderArgs

func CreationRoleProviderPtr(v *CreationRoleProviderArgs) CreationRoleProviderPtrInput {
	return (*creationRoleProviderPtrType)(v)
}

func (*creationRoleProviderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderPtrOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProviderOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CreationRoleProvider) *CreationRoleProvider {
		return &v
	}).(CreationRoleProviderPtrOutput)
}

func (o CreationRoleProviderOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v CreationRoleProvider) *aws.Provider { return v.Provider }).(aws.ProviderOutput)
}

func (o CreationRoleProviderOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v CreationRoleProvider) *iam.Role { return v.Role }).(iam.RoleOutput)
}

type CreationRoleProviderPtrOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) Elem() CreationRoleProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) CreationRoleProvider {
		if v != nil {
			return *v
		}
		var ret CreationRoleProvider
		return ret
	}).(CreationRoleProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *aws.Provider {
		if v == nil {
			return nil
		}
		return v.Provider
	}).(aws.ProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *iam.Role {
		if v == nil {
			return nil
		}
		return v.Role
	}).(iam.RoleOutput)
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfile struct {
	// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
	PodExecutionRoleArn *string `pulumi:"podExecutionRoleArn"`
	// Specify the namespace and label selectors to use for launching pods into Fargate.
	Selectors []eks.FargateProfileSelector `pulumi:"selectors"`
	// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
	SubnetIds []string `pulumi:"subnetIds"`
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptions struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName *string `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn *string `pulumi:"roleArn"`
}

// KubeconfigOptionsInput is an input type that accepts KubeconfigOptionsArgs and KubeconfigOptionsOutput values.
// You can construct a concrete instance of `KubeconfigOptionsInput` via:
//
//	KubeconfigOptionsArgs{...}
type KubeconfigOptionsInput interface {
	pulumi.Input

	ToKubeconfigOptionsOutput() KubeconfigOptionsOutput
	ToKubeconfigOptionsOutputWithContext(context.Context) KubeconfigOptionsOutput
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsArgs struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName pulumi.StringPtrInput `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn pulumi.StringPtrInput `pulumi:"roleArn"`
}

func (KubeconfigOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return i.ToKubeconfigOptionsOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput)
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput).ToKubeconfigOptionsPtrOutputWithContext(ctx)
}

// KubeconfigOptionsPtrInput is an input type that accepts KubeconfigOptionsArgs, KubeconfigOptionsPtr and KubeconfigOptionsPtrOutput values.
// You can construct a concrete instance of `KubeconfigOptionsPtrInput` via:
//
//	        KubeconfigOptionsArgs{...}
//
//	or:
//
//	        nil
type KubeconfigOptionsPtrInput interface {
	pulumi.Input

	ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput
	ToKubeconfigOptionsPtrOutputWithContext(context.Context) KubeconfigOptionsPtrOutput
}

type kubeconfigOptionsPtrType KubeconfigOptionsArgs

func KubeconfigOptionsPtr(v *KubeconfigOptionsArgs) KubeconfigOptionsPtrInput {
	return (*kubeconfigOptionsPtrType)(v)
}

func (*kubeconfigOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsPtrOutput)
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KubeconfigOptions) *KubeconfigOptions {
		return &v
	}).(KubeconfigOptionsPtrOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.ProfileName }).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.RoleArn }).(pulumi.StringPtrOutput)
}

type KubeconfigOptionsPtrOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) Elem() KubeconfigOptionsOutput {
	return o.ApplyT(func(v *KubeconfigOptions) KubeconfigOptions {
		if v != nil {
			return *v
		}
		var ret KubeconfigOptions
		return ret
	}).(KubeconfigOptionsOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsPtrOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.ProfileName
	}).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupData struct {
	// The AutoScalingGroup name for the node group.
	AutoScalingGroupName string `pulumi:"autoScalingGroupName"`
	// The CloudFormation Stack which defines the Node AutoScalingGroup.
	CfnStack *cloudformation.Stack `pulumi:"cfnStack"`
	// The additional security groups for the node group that captures user-specific rules.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// The security group for the node group to communicate with the cluster.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupDataOutput struct{ *pulumi.OutputState }

func (NodeGroupDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutput() NodeGroupDataOutput {
	return o
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutputWithContext(ctx context.Context) NodeGroupDataOutput {
	return o
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataOutput) AutoScalingGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v NodeGroupData) string { return v.AutoScalingGroupName }).(pulumi.StringOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v NodeGroupData) *cloudformation.Stack { return v.CfnStack }).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v NodeGroupData) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v NodeGroupData) *ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

type NodeGroupDataPtrOutput struct{ *pulumi.OutputState }

func (NodeGroupDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) Elem() NodeGroupDataOutput {
	return o.ApplyT(func(v *NodeGroupData) NodeGroupData {
		if v != nil {
			return *v
		}
		var ret NodeGroupData
		return ret
	}).(NodeGroupDataOutput)
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataPtrOutput) AutoScalingGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeGroupData) *string {
		if v == nil {
			return nil
		}
		return &v.AutoScalingGroupName
	}).(pulumi.StringPtrOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataPtrOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v *NodeGroupData) *cloudformation.Stack {
		if v == nil {
			return nil
		}
		return v.CfnStack
	}).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *NodeGroupData) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *NodeGroupData) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMapping struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn string `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username string `pulumi:"username"`
}

// RoleMappingInput is an input type that accepts RoleMappingArgs and RoleMappingOutput values.
// You can construct a concrete instance of `RoleMappingInput` via:
//
//	RoleMappingArgs{...}
type RoleMappingInput interface {
	pulumi.Input

	ToRoleMappingOutput() RoleMappingOutput
	ToRoleMappingOutputWithContext(context.Context) RoleMappingOutput
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingArgs struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username pulumi.StringInput `pulumi:"username"`
}

func (RoleMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (i RoleMappingArgs) ToRoleMappingOutput() RoleMappingOutput {
	return i.ToRoleMappingOutputWithContext(context.Background())
}

func (i RoleMappingArgs) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingOutput)
}

// RoleMappingArrayInput is an input type that accepts RoleMappingArray and RoleMappingArrayOutput values.
// You can construct a concrete instance of `RoleMappingArrayInput` via:
//
//	RoleMappingArray{ RoleMappingArgs{...} }
type RoleMappingArrayInput interface {
	pulumi.Input

	ToRoleMappingArrayOutput() RoleMappingArrayOutput
	ToRoleMappingArrayOutputWithContext(context.Context) RoleMappingArrayOutput
}

type RoleMappingArray []RoleMappingInput

func (RoleMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (i RoleMappingArray) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return i.ToRoleMappingArrayOutputWithContext(context.Background())
}

func (i RoleMappingArray) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingArrayOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingOutput struct{ *pulumi.OutputState }

func (RoleMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (o RoleMappingOutput) ToRoleMappingOutput() RoleMappingOutput {
	return o
}

func (o RoleMappingOutput) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the role is mapped.
func (o RoleMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RoleMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM role to add.
func (o RoleMappingOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.RoleArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
func (o RoleMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.Username }).(pulumi.StringOutput)
}

type RoleMappingArrayOutput struct{ *pulumi.OutputState }

func (RoleMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) Index(i pulumi.IntInput) RoleMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RoleMapping {
		return vs[0].([]RoleMapping)[vs[1].(int)]
	}).(RoleMappingOutput)
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClass struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand.
	AllowVolumeExpansion *bool `pulumi:"allowVolumeExpansion"`
	// True if this storage class should be a default storage class for the cluster.
	//
	// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
	//
	// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
	Default *bool `pulumi:"default"`
	// Denotes whether the EBS volume should be encrypted.
	Encrypted *bool `pulumi:"encrypted"`
	// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
	IopsPerGb *int `pulumi:"iopsPerGb"`
	// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions []string `pulumi:"mountOptions"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy *string `pulumi:"reclaimPolicy"`
	// The EBS volume type.
	Type string `pulumi:"type"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode *string `pulumi:"volumeBindingMode"`
	// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
	Zones []string `pulumi:"zones"`
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type Taint struct {
	// The effect of the taint.
	Effect string `pulumi:"effect"`
	// The value of the taint.
	Value string `pulumi:"value"`
}

// TaintInput is an input type that accepts TaintArgs and TaintOutput values.
// You can construct a concrete instance of `TaintInput` via:
//
//	TaintArgs{...}
type TaintInput interface {
	pulumi.Input

	ToTaintOutput() TaintOutput
	ToTaintOutputWithContext(context.Context) TaintOutput
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintArgs struct {
	// The effect of the taint.
	Effect string `pulumi:"effect"`
	// The value of the taint.
	Value string `pulumi:"value"`
}

func (TaintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (i TaintArgs) ToTaintOutput() TaintOutput {
	return i.ToTaintOutputWithContext(context.Background())
}

func (i TaintArgs) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintOutput)
}

// TaintMapInput is an input type that accepts TaintMap and TaintMapOutput values.
// You can construct a concrete instance of `TaintMapInput` via:
//
//	TaintMap{ "key": TaintArgs{...} }
type TaintMapInput interface {
	pulumi.Input

	ToTaintMapOutput() TaintMapOutput
	ToTaintMapOutputWithContext(context.Context) TaintMapOutput
}

type TaintMap map[string]TaintInput

func (TaintMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (i TaintMap) ToTaintMapOutput() TaintMapOutput {
	return i.ToTaintMapOutputWithContext(context.Background())
}

func (i TaintMap) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintMapOutput)
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintOutput struct{ *pulumi.OutputState }

func (TaintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (o TaintOutput) ToTaintOutput() TaintOutput {
	return o
}

func (o TaintOutput) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return o
}

// The effect of the taint.
func (o TaintOutput) Effect() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Effect }).(pulumi.StringOutput)
}

// The value of the taint.
func (o TaintOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Value }).(pulumi.StringOutput)
}

type TaintMapOutput struct{ *pulumi.OutputState }

func (TaintMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (o TaintMapOutput) ToTaintMapOutput() TaintMapOutput {
	return o
}

func (o TaintMapOutput) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return o
}

func (o TaintMapOutput) MapIndex(k pulumi.StringInput) TaintOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Taint {
		return vs[0].(map[string]Taint)[vs[1].(string)]
	}).(TaintOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMapping struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn string `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username string `pulumi:"username"`
}

// UserMappingInput is an input type that accepts UserMappingArgs and UserMappingOutput values.
// You can construct a concrete instance of `UserMappingInput` via:
//
//	UserMappingArgs{...}
type UserMappingInput interface {
	pulumi.Input

	ToUserMappingOutput() UserMappingOutput
	ToUserMappingOutputWithContext(context.Context) UserMappingOutput
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingArgs struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn pulumi.StringInput `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username pulumi.StringInput `pulumi:"username"`
}

func (UserMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (i UserMappingArgs) ToUserMappingOutput() UserMappingOutput {
	return i.ToUserMappingOutputWithContext(context.Background())
}

func (i UserMappingArgs) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingOutput)
}

// UserMappingArrayInput is an input type that accepts UserMappingArray and UserMappingArrayOutput values.
// You can construct a concrete instance of `UserMappingArrayInput` via:
//
//	UserMappingArray{ UserMappingArgs{...} }
type UserMappingArrayInput interface {
	pulumi.Input

	ToUserMappingArrayOutput() UserMappingArrayOutput
	ToUserMappingArrayOutputWithContext(context.Context) UserMappingArrayOutput
}

type UserMappingArray []UserMappingInput

func (UserMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (i UserMappingArray) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return i.ToUserMappingArrayOutputWithContext(context.Background())
}

func (i UserMappingArray) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingArrayOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingOutput struct{ *pulumi.OutputState }

func (UserMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (o UserMappingOutput) ToUserMappingOutput() UserMappingOutput {
	return o
}

func (o UserMappingOutput) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the user is mapped to.
func (o UserMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM user to add.
func (o UserMappingOutput) UserArn() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.UserArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
func (o UserMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.Username }).(pulumi.StringOutput)
}

type UserMappingArrayOutput struct{ *pulumi.OutputState }

func (UserMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) Index(i pulumi.IntInput) UserMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserMapping {
		return vs[0].([]UserMapping)[vs[1].(int)]
	}).(UserMappingOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptions struct {
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter *bool `pulumi:"cniConfigureRpfilter"`
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg *bool `pulumi:"cniCustomNetworkCfg"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat *bool `pulumi:"cniExternalSnat"`
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig *bool `pulumi:"customNetworkConfig"`
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux *bool `pulumi:"disableTcpEarlyDemux"`
	// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni *bool `pulumi:"enablePodEni"`
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation *bool `pulumi:"enablePrefixDelegation"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef *string `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu *int `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat *bool `pulumi:"externalSnat"`
	// Specifies the container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image *string `pulumi:"image"`
	// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI init container image in ECR.
	InitImage *string `pulumi:"initImage"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile *string `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel *string `pulumi:"logLevel"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport *bool `pulumi:"nodePortSupport"`
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged *bool `pulumi:"securityContextPrivileged"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix *string `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget *int `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget *int `pulumi:"warmIpTarget"`
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget *int `pulumi:"warmPrefixTarget"`
}

// VpcCniOptionsInput is an input type that accepts VpcCniOptionsArgs and VpcCniOptionsOutput values.
// You can construct a concrete instance of `VpcCniOptionsInput` via:
//
//	VpcCniOptionsArgs{...}
type VpcCniOptionsInput interface {
	pulumi.Input

	ToVpcCniOptionsOutput() VpcCniOptionsOutput
	ToVpcCniOptionsOutputWithContext(context.Context) VpcCniOptionsOutput
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsArgs struct {
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter pulumi.BoolPtrInput `pulumi:"cniConfigureRpfilter"`
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg pulumi.BoolPtrInput `pulumi:"cniCustomNetworkCfg"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat pulumi.BoolPtrInput `pulumi:"cniExternalSnat"`
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig pulumi.BoolPtrInput `pulumi:"customNetworkConfig"`
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux pulumi.BoolPtrInput `pulumi:"disableTcpEarlyDemux"`
	// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
	EnableIpv6 pulumi.BoolPtrInput `pulumi:"enableIpv6"`
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni pulumi.BoolPtrInput `pulumi:"enablePodEni"`
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation pulumi.BoolPtrInput `pulumi:"enablePrefixDelegation"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef pulumi.StringPtrInput `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu pulumi.IntPtrInput `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat pulumi.BoolPtrInput `pulumi:"externalSnat"`
	// Specifies the container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI init container image in ECR.
	InitImage pulumi.StringPtrInput `pulumi:"initImage"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile pulumi.StringPtrInput `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel pulumi.StringPtrInput `pulumi:"logLevel"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport pulumi.BoolPtrInput `pulumi:"nodePortSupport"`
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged pulumi.BoolPtrInput `pulumi:"securityContextPrivileged"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix pulumi.StringPtrInput `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget pulumi.IntPtrInput `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget pulumi.IntPtrInput `pulumi:"warmIpTarget"`
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget pulumi.IntPtrInput `pulumi:"warmPrefixTarget"`
}

func (VpcCniOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return i.ToVpcCniOptionsOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput)
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput).ToVpcCniOptionsPtrOutputWithContext(ctx)
}

// VpcCniOptionsPtrInput is an input type that accepts VpcCniOptionsArgs, VpcCniOptionsPtr and VpcCniOptionsPtrOutput values.
// You can construct a concrete instance of `VpcCniOptionsPtrInput` via:
//
//	        VpcCniOptionsArgs{...}
//
//	or:
//
//	        nil
type VpcCniOptionsPtrInput interface {
	pulumi.Input

	ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput
	ToVpcCniOptionsPtrOutputWithContext(context.Context) VpcCniOptionsPtrOutput
}

type vpcCniOptionsPtrType VpcCniOptionsArgs

func VpcCniOptionsPtr(v *VpcCniOptionsArgs) VpcCniOptionsPtrInput {
	return (*vpcCniOptionsPtrType)(v)
}

func (*vpcCniOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsPtrOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VpcCniOptions) *VpcCniOptions {
		return &v
	}).(VpcCniOptionsPtrOutput)
}

// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
func (o VpcCniOptionsOutput) CniConfigureRpfilter() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniConfigureRpfilter }).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
func (o VpcCniOptionsOutput) CniCustomNetworkCfg() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniCustomNetworkCfg }).(pulumi.BoolPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
func (o VpcCniOptionsOutput) CniExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniExternalSnat }).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CustomNetworkConfig }).(pulumi.BoolPtrOutput)
}

// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
func (o VpcCniOptionsOutput) DisableTcpEarlyDemux() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.DisableTcpEarlyDemux }).(pulumi.BoolPtrOutput)
}

// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
func (o VpcCniOptionsOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
func (o VpcCniOptionsOutput) EnablePodEni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnablePodEni }).(pulumi.BoolPtrOutput)
}

// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
func (o VpcCniOptionsOutput) EnablePrefixDelegation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnablePrefixDelegation }).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.EniConfigLabelDef }).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.EniMtu }).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.ExternalSnat }).(pulumi.BoolPtrOutput)
}

// Specifies the container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI init container image in ECR.
func (o VpcCniOptionsOutput) InitImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.InitImage }).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogFile }).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogLevel }).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.NodePortSupport }).(pulumi.BoolPtrOutput)
}

// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
func (o VpcCniOptionsOutput) SecurityContextPrivileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.SecurityContextPrivileged }).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.VethPrefix }).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmEniTarget }).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmIpTarget }).(pulumi.IntPtrOutput)
}

// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
func (o VpcCniOptionsOutput) WarmPrefixTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmPrefixTarget }).(pulumi.IntPtrOutput)
}

type VpcCniOptionsPtrOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) Elem() VpcCniOptionsOutput {
	return o.ApplyT(func(v *VpcCniOptions) VpcCniOptions {
		if v != nil {
			return *v
		}
		var ret VpcCniOptions
		return ret
	}).(VpcCniOptionsOutput)
}

// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
func (o VpcCniOptionsPtrOutput) CniConfigureRpfilter() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniConfigureRpfilter
	}).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
func (o VpcCniOptionsPtrOutput) CniCustomNetworkCfg() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniCustomNetworkCfg
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
func (o VpcCniOptionsPtrOutput) CniExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniExternalSnat
	}).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CustomNetworkConfig
	}).(pulumi.BoolPtrOutput)
}

// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
func (o VpcCniOptionsPtrOutput) DisableTcpEarlyDemux() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableTcpEarlyDemux
	}).(pulumi.BoolPtrOutput)
}

// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
func (o VpcCniOptionsPtrOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnableIpv6
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
func (o VpcCniOptionsPtrOutput) EnablePodEni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnablePodEni
	}).(pulumi.BoolPtrOutput)
}

// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
func (o VpcCniOptionsPtrOutput) EnablePrefixDelegation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnablePrefixDelegation
	}).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.EniConfigLabelDef
	}).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsPtrOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.EniMtu
	}).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.ExternalSnat
	}).(pulumi.BoolPtrOutput)
}

// Specifies the container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI init container image in ECR.
func (o VpcCniOptionsPtrOutput) InitImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.InitImage
	}).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsPtrOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogFile
	}).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsPtrOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogLevel
	}).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsPtrOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodePortSupport
	}).(pulumi.BoolPtrOutput)
}

// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
func (o VpcCniOptionsPtrOutput) SecurityContextPrivileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.SecurityContextPrivileged
	}).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsPtrOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.VethPrefix
	}).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsPtrOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmEniTarget
	}).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsPtrOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmIpTarget
	}).(pulumi.IntPtrOutput)
}

// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
func (o VpcCniOptionsPtrOutput) WarmPrefixTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmPrefixTarget
	}).(pulumi.IntPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterNodeGroupOptionsInput)(nil)).Elem(), ClusterNodeGroupOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterNodeGroupOptionsPtrInput)(nil)).Elem(), ClusterNodeGroupOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CreationRoleProviderInput)(nil)).Elem(), CreationRoleProviderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CreationRoleProviderPtrInput)(nil)).Elem(), CreationRoleProviderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeconfigOptionsInput)(nil)).Elem(), KubeconfigOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeconfigOptionsPtrInput)(nil)).Elem(), KubeconfigOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleMappingInput)(nil)).Elem(), RoleMappingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleMappingArrayInput)(nil)).Elem(), RoleMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaintInput)(nil)).Elem(), TaintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaintMapInput)(nil)).Elem(), TaintMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMappingInput)(nil)).Elem(), UserMappingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMappingArrayInput)(nil)).Elem(), UserMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniOptionsInput)(nil)).Elem(), VpcCniOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniOptionsPtrInput)(nil)).Elem(), VpcCniOptionsArgs{})
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsOutput{})
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsPtrOutput{})
	pulumi.RegisterOutputType(CoreDataOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderPtrOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsPtrOutput{})
	pulumi.RegisterOutputType(NodeGroupDataOutput{})
	pulumi.RegisterOutputType(NodeGroupDataPtrOutput{})
	pulumi.RegisterOutputType(RoleMappingOutput{})
	pulumi.RegisterOutputType(RoleMappingArrayOutput{})
	pulumi.RegisterOutputType(TaintOutput{})
	pulumi.RegisterOutputType(TaintMapOutput{})
	pulumi.RegisterOutputType(UserMappingOutput{})
	pulumi.RegisterOutputType(UserMappingArrayOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsPtrOutput{})
}
