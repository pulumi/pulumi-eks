// Code generated by pulumi-gen-eks DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/cloudformation"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/iam"
	"github.com/pulumi/pulumi-eks/sdk/v2/go/eks/utilities"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	storagev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/storage/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Access entries allow an IAM principal to access your cluster.
//
// You have the following options for authorizing an IAM principal to access Kubernetes objects on your cluster: Kubernetes role-based access control (RBAC), Amazon EKS, or both.
// Kubernetes RBAC authorization requires you to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects, in addition to managing access entries. If you use Amazon EKS authorization exclusively, you don't need to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects.
type AccessEntry struct {
	// The access policies to associate to the access entry.
	AccessPolicies map[string]AccessPolicyAssociation `pulumi:"accessPolicies"`
	// A list of groups within Kubernetes to which the IAM principal is mapped to.
	KubernetesGroups []string `pulumi:"kubernetesGroups"`
	// The IAM Principal ARN which requires Authentication access to the EKS cluster.
	PrincipalArn string `pulumi:"principalArn"`
	// The tags to apply to the AccessEntry.
	Tags map[string]string `pulumi:"tags"`
	// The type of the new access entry. Valid values are STANDARD, FARGATE_LINUX, EC2_LINUX, and EC2_WINDOWS.
	// Defaults to STANDARD which provides the standard workflow. EC2_LINUX, EC2_WINDOWS, FARGATE_LINUX types disallow users to input a username or kubernetesGroup, and prevent associating access policies.
	Type *AccessEntryType `pulumi:"type"`
	// Defaults to the principalArn if the principal is a user, else defaults to assume-role/session-name.
	Username *string `pulumi:"username"`
}

// AccessEntryInput is an input type that accepts AccessEntryArgs and AccessEntryOutput values.
// You can construct a concrete instance of `AccessEntryInput` via:
//
//	AccessEntryArgs{...}
type AccessEntryInput interface {
	pulumi.Input

	ToAccessEntryOutput() AccessEntryOutput
	ToAccessEntryOutputWithContext(context.Context) AccessEntryOutput
}

// Access entries allow an IAM principal to access your cluster.
//
// You have the following options for authorizing an IAM principal to access Kubernetes objects on your cluster: Kubernetes role-based access control (RBAC), Amazon EKS, or both.
// Kubernetes RBAC authorization requires you to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects, in addition to managing access entries. If you use Amazon EKS authorization exclusively, you don't need to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects.
type AccessEntryArgs struct {
	// The access policies to associate to the access entry.
	AccessPolicies map[string]AccessPolicyAssociationInput `pulumi:"accessPolicies"`
	// A list of groups within Kubernetes to which the IAM principal is mapped to.
	KubernetesGroups pulumi.StringArrayInput `pulumi:"kubernetesGroups"`
	// The IAM Principal ARN which requires Authentication access to the EKS cluster.
	PrincipalArn pulumi.StringInput `pulumi:"principalArn"`
	// The tags to apply to the AccessEntry.
	Tags pulumi.StringMapInput `pulumi:"tags"`
	// The type of the new access entry. Valid values are STANDARD, FARGATE_LINUX, EC2_LINUX, and EC2_WINDOWS.
	// Defaults to STANDARD which provides the standard workflow. EC2_LINUX, EC2_WINDOWS, FARGATE_LINUX types disallow users to input a username or kubernetesGroup, and prevent associating access policies.
	Type AccessEntryTypePtrInput `pulumi:"type"`
	// Defaults to the principalArn if the principal is a user, else defaults to assume-role/session-name.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (AccessEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessEntry)(nil)).Elem()
}

func (i AccessEntryArgs) ToAccessEntryOutput() AccessEntryOutput {
	return i.ToAccessEntryOutputWithContext(context.Background())
}

func (i AccessEntryArgs) ToAccessEntryOutputWithContext(ctx context.Context) AccessEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessEntryOutput)
}

// AccessEntryArrayInput is an input type that accepts AccessEntryArray and AccessEntryArrayOutput values.
// You can construct a concrete instance of `AccessEntryArrayInput` via:
//
//	AccessEntryArray{ AccessEntryArgs{...} }
type AccessEntryArrayInput interface {
	pulumi.Input

	ToAccessEntryArrayOutput() AccessEntryArrayOutput
	ToAccessEntryArrayOutputWithContext(context.Context) AccessEntryArrayOutput
}

type AccessEntryArray []AccessEntryInput

func (AccessEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AccessEntry)(nil)).Elem()
}

func (i AccessEntryArray) ToAccessEntryArrayOutput() AccessEntryArrayOutput {
	return i.ToAccessEntryArrayOutputWithContext(context.Background())
}

func (i AccessEntryArray) ToAccessEntryArrayOutputWithContext(ctx context.Context) AccessEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessEntryArrayOutput)
}

// Access entries allow an IAM principal to access your cluster.
//
// You have the following options for authorizing an IAM principal to access Kubernetes objects on your cluster: Kubernetes role-based access control (RBAC), Amazon EKS, or both.
// Kubernetes RBAC authorization requires you to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects, in addition to managing access entries. If you use Amazon EKS authorization exclusively, you don't need to create and manage Kubernetes Role , ClusterRole , RoleBinding , and ClusterRoleBinding objects.
type AccessEntryOutput struct{ *pulumi.OutputState }

func (AccessEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessEntry)(nil)).Elem()
}

func (o AccessEntryOutput) ToAccessEntryOutput() AccessEntryOutput {
	return o
}

func (o AccessEntryOutput) ToAccessEntryOutputWithContext(ctx context.Context) AccessEntryOutput {
	return o
}

// The access policies to associate to the access entry.
func (o AccessEntryOutput) AccessPolicies() AccessPolicyAssociationMapOutput {
	return o.ApplyT(func(v AccessEntry) map[string]AccessPolicyAssociation { return v.AccessPolicies }).(AccessPolicyAssociationMapOutput)
}

// A list of groups within Kubernetes to which the IAM principal is mapped to.
func (o AccessEntryOutput) KubernetesGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AccessEntry) []string { return v.KubernetesGroups }).(pulumi.StringArrayOutput)
}

// The IAM Principal ARN which requires Authentication access to the EKS cluster.
func (o AccessEntryOutput) PrincipalArn() pulumi.StringOutput {
	return o.ApplyT(func(v AccessEntry) string { return v.PrincipalArn }).(pulumi.StringOutput)
}

// The tags to apply to the AccessEntry.
func (o AccessEntryOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v AccessEntry) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The type of the new access entry. Valid values are STANDARD, FARGATE_LINUX, EC2_LINUX, and EC2_WINDOWS.
// Defaults to STANDARD which provides the standard workflow. EC2_LINUX, EC2_WINDOWS, FARGATE_LINUX types disallow users to input a username or kubernetesGroup, and prevent associating access policies.
func (o AccessEntryOutput) Type() AccessEntryTypePtrOutput {
	return o.ApplyT(func(v AccessEntry) *AccessEntryType { return v.Type }).(AccessEntryTypePtrOutput)
}

// Defaults to the principalArn if the principal is a user, else defaults to assume-role/session-name.
func (o AccessEntryOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AccessEntry) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type AccessEntryArrayOutput struct{ *pulumi.OutputState }

func (AccessEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AccessEntry)(nil)).Elem()
}

func (o AccessEntryArrayOutput) ToAccessEntryArrayOutput() AccessEntryArrayOutput {
	return o
}

func (o AccessEntryArrayOutput) ToAccessEntryArrayOutputWithContext(ctx context.Context) AccessEntryArrayOutput {
	return o
}

func (o AccessEntryArrayOutput) Index(i pulumi.IntInput) AccessEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AccessEntry {
		return vs[0].([]AccessEntry)[vs[1].(int)]
	}).(AccessEntryOutput)
}

// Associates an access policy and its scope to an IAM principal.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html
type AccessPolicyAssociation struct {
	// The scope of the access policy association. This controls whether the access policy is scoped to the cluster or to a particular namespace.
	AccessScope eks.AccessPolicyAssociationAccessScope `pulumi:"accessScope"`
	// The ARN of the access policy to associate with the principal
	PolicyArn string `pulumi:"policyArn"`
}

// AccessPolicyAssociationInput is an input type that accepts AccessPolicyAssociationArgs and AccessPolicyAssociationOutput values.
// You can construct a concrete instance of `AccessPolicyAssociationInput` via:
//
//	AccessPolicyAssociationArgs{...}
type AccessPolicyAssociationInput interface {
	pulumi.Input

	ToAccessPolicyAssociationOutput() AccessPolicyAssociationOutput
	ToAccessPolicyAssociationOutputWithContext(context.Context) AccessPolicyAssociationOutput
}

// Associates an access policy and its scope to an IAM principal.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html
type AccessPolicyAssociationArgs struct {
	// The scope of the access policy association. This controls whether the access policy is scoped to the cluster or to a particular namespace.
	AccessScope eks.AccessPolicyAssociationAccessScopeInput `pulumi:"accessScope"`
	// The ARN of the access policy to associate with the principal
	PolicyArn pulumi.StringInput `pulumi:"policyArn"`
}

func (AccessPolicyAssociationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessPolicyAssociation)(nil)).Elem()
}

func (i AccessPolicyAssociationArgs) ToAccessPolicyAssociationOutput() AccessPolicyAssociationOutput {
	return i.ToAccessPolicyAssociationOutputWithContext(context.Background())
}

func (i AccessPolicyAssociationArgs) ToAccessPolicyAssociationOutputWithContext(ctx context.Context) AccessPolicyAssociationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessPolicyAssociationOutput)
}

// AccessPolicyAssociationMapInput is an input type that accepts AccessPolicyAssociationMap and AccessPolicyAssociationMapOutput values.
// You can construct a concrete instance of `AccessPolicyAssociationMapInput` via:
//
//	AccessPolicyAssociationMap{ "key": AccessPolicyAssociationArgs{...} }
type AccessPolicyAssociationMapInput interface {
	pulumi.Input

	ToAccessPolicyAssociationMapOutput() AccessPolicyAssociationMapOutput
	ToAccessPolicyAssociationMapOutputWithContext(context.Context) AccessPolicyAssociationMapOutput
}

type AccessPolicyAssociationMap map[string]AccessPolicyAssociationInput

func (AccessPolicyAssociationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]AccessPolicyAssociation)(nil)).Elem()
}

func (i AccessPolicyAssociationMap) ToAccessPolicyAssociationMapOutput() AccessPolicyAssociationMapOutput {
	return i.ToAccessPolicyAssociationMapOutputWithContext(context.Background())
}

func (i AccessPolicyAssociationMap) ToAccessPolicyAssociationMapOutputWithContext(ctx context.Context) AccessPolicyAssociationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessPolicyAssociationMapOutput)
}

// Associates an access policy and its scope to an IAM principal.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html
type AccessPolicyAssociationOutput struct{ *pulumi.OutputState }

func (AccessPolicyAssociationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessPolicyAssociation)(nil)).Elem()
}

func (o AccessPolicyAssociationOutput) ToAccessPolicyAssociationOutput() AccessPolicyAssociationOutput {
	return o
}

func (o AccessPolicyAssociationOutput) ToAccessPolicyAssociationOutputWithContext(ctx context.Context) AccessPolicyAssociationOutput {
	return o
}

// The scope of the access policy association. This controls whether the access policy is scoped to the cluster or to a particular namespace.
func (o AccessPolicyAssociationOutput) AccessScope() eks.AccessPolicyAssociationAccessScopeOutput {
	return o.ApplyT(func(v AccessPolicyAssociation) eks.AccessPolicyAssociationAccessScope { return v.AccessScope }).(eks.AccessPolicyAssociationAccessScopeOutput)
}

// The ARN of the access policy to associate with the principal
func (o AccessPolicyAssociationOutput) PolicyArn() pulumi.StringOutput {
	return o.ApplyT(func(v AccessPolicyAssociation) string { return v.PolicyArn }).(pulumi.StringOutput)
}

type AccessPolicyAssociationMapOutput struct{ *pulumi.OutputState }

func (AccessPolicyAssociationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]AccessPolicyAssociation)(nil)).Elem()
}

func (o AccessPolicyAssociationMapOutput) ToAccessPolicyAssociationMapOutput() AccessPolicyAssociationMapOutput {
	return o
}

func (o AccessPolicyAssociationMapOutput) ToAccessPolicyAssociationMapOutputWithContext(ctx context.Context) AccessPolicyAssociationMapOutput {
	return o
}

func (o AccessPolicyAssociationMapOutput) MapIndex(k pulumi.StringInput) AccessPolicyAssociationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) AccessPolicyAssociation {
		return vs[0].(map[string]AccessPolicyAssociation)[vs[1].(string)]
	}).(AccessPolicyAssociationOutput)
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptions struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId *string `pulumi:"amiId"`
	// The AMI Type to use for the worker nodes.
	//
	// Only applicable when setting an AMI ID that is of type `arm64`.
	//
	// Note: `amiType` and `gpu` are mutually exclusive.
	AmiType *string `pulumi:"amiType"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags map[string]string `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs *string `pulumi:"bootstrapExtraArgs"`
	// The configuration settings for Bottlerocket OS.
	// The settings will get merged with the base settings the provider uses to configure Bottlerocket.
	//
	// This includes:
	//   - settings.kubernetes.api-server
	//   - settings.kubernetes.cluster-certificate
	//   - settings.kubernetes.cluster-name
	//   - settings.kubernetes.cluster-dns-ip
	//
	// For an overview of the available settings, see https://bottlerocket.dev/en/os/1.20.x/api/settings/.
	BottlerocketSettings map[string]interface{} `pulumi:"bottlerocketSettings"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags map[string]string `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule *ec2.SecurityGroupRule `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity *int `pulumi:"desiredCapacity"`
	// Enables/disables detailed monitoring of the EC2 instances.
	//
	// With detailed monitoring, all metrics, including status check metrics, are available in 1-minute intervals.
	// When enabled, you can also get aggregated data across groups of similar instances.
	//
	// Note: You are charged per metric that is sent to CloudWatch. You are not charged for data storage.
	// For more information, see "Paid tier" and "Example 1 - EC2 Detailed Monitoring" here https://aws.amazon.com/cloudwatch/pricing/.
	EnableDetailedMonitoring *bool `pulumi:"enableDetailedMonitoring"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice *bool `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu *bool `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile *iam.InstanceProfile `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType *string `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName *string `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
	KubeletExtraArgs *string `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize *int `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize *int `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress *bool `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey *string `pulumi:"nodePublicKey"`
	// Whether the root block device should be deleted on termination of the instance. Defaults to true.
	NodeRootVolumeDeleteOnTermination *bool `pulumi:"nodeRootVolumeDeleteOnTermination"`
	// Whether to encrypt a cluster node's root volume. Defaults to false.
	NodeRootVolumeEncrypted *bool `pulumi:"nodeRootVolumeEncrypted"`
	// The amount of provisioned IOPS. This is only valid with a volumeType of 'io1'.
	NodeRootVolumeIops *int `pulumi:"nodeRootVolumeIops"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize *int `pulumi:"nodeRootVolumeSize"`
	// Provisioned throughput performance in integer MiB/s for a cluster node's root volume. This is only valid with a volumeType of 'gp3'.
	NodeRootVolumeThroughput *int `pulumi:"nodeRootVolumeThroughput"`
	// Configured EBS type for a cluster node's root volume. Default is 'gp2'. Supported values are 'standard', 'gp2', 'gp3', 'st1', 'sc1', 'io1'.
	NodeRootVolumeType *string `pulumi:"nodeRootVolumeType"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds []string `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData *string `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride *string `pulumi:"nodeUserDataOverride"`
	// Extra nodeadm configuration sections to be added to the nodeadm user data. This can be shell scripts, nodeadm NodeConfig or any other user data compatible script. When configuring additional nodeadm NodeConfig sections, they'll be merged with the base settings the provider sets. You can overwrite base settings or provide additional settings this way.
	// The base settings the provider sets are:
	//   - cluster.name
	//   - cluster.apiServerEndpoint
	//   - cluster.certificateAuthority
	//   - cluster.cidr
	//
	// Note: This is only applicable when using AL2023.
	// See for more details:
	//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/
	//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/
	NodeadmExtraOptions []NodeadmOptions `pulumi:"nodeadmExtraOptions"`
	// The type of OS to use for the node group. Will be used to determine the right EKS optimized AMI to use based on the instance types and gpu configuration.
	// Valid values are `AL2`, `AL2023` and `Bottlerocket`.
	//
	// Defaults to `AL2`.
	OperatingSystem *OperatingSystem `pulumi:"operatingSystem"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice *string `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints map[string]Taint `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version *string `pulumi:"version"`
}

// ClusterNodeGroupOptionsInput is an input type that accepts ClusterNodeGroupOptionsArgs and ClusterNodeGroupOptionsOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsInput` via:
//
//	ClusterNodeGroupOptionsArgs{...}
type ClusterNodeGroupOptionsInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput
	ToClusterNodeGroupOptionsOutputWithContext(context.Context) ClusterNodeGroupOptionsOutput
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsArgs struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId pulumi.StringPtrInput `pulumi:"amiId"`
	// The AMI Type to use for the worker nodes.
	//
	// Only applicable when setting an AMI ID that is of type `arm64`.
	//
	// Note: `amiType` and `gpu` are mutually exclusive.
	AmiType pulumi.StringPtrInput `pulumi:"amiType"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags pulumi.StringMapInput `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs *string `pulumi:"bootstrapExtraArgs"`
	// The configuration settings for Bottlerocket OS.
	// The settings will get merged with the base settings the provider uses to configure Bottlerocket.
	//
	// This includes:
	//   - settings.kubernetes.api-server
	//   - settings.kubernetes.cluster-certificate
	//   - settings.kubernetes.cluster-name
	//   - settings.kubernetes.cluster-dns-ip
	//
	// For an overview of the available settings, see https://bottlerocket.dev/en/os/1.20.x/api/settings/.
	BottlerocketSettings pulumi.MapInput `pulumi:"bottlerocketSettings"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags pulumi.StringMapInput `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule ec2.SecurityGroupRuleInput `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity pulumi.IntPtrInput `pulumi:"desiredCapacity"`
	// Enables/disables detailed monitoring of the EC2 instances.
	//
	// With detailed monitoring, all metrics, including status check metrics, are available in 1-minute intervals.
	// When enabled, you can also get aggregated data across groups of similar instances.
	//
	// Note: You are charged per metric that is sent to CloudWatch. You are not charged for data storage.
	// For more information, see "Paid tier" and "Example 1 - EC2 Detailed Monitoring" here https://aws.amazon.com/cloudwatch/pricing/.
	EnableDetailedMonitoring pulumi.BoolPtrInput `pulumi:"enableDetailedMonitoring"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice pulumi.BoolPtrInput `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups ec2.SecurityGroupArrayInput `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu pulumi.BoolPtrInput `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile *iam.InstanceProfile `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
	KubeletExtraArgs *string `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize pulumi.IntPtrInput `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize pulumi.IntPtrInput `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress *bool `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey pulumi.StringPtrInput `pulumi:"nodePublicKey"`
	// Whether the root block device should be deleted on termination of the instance. Defaults to true.
	NodeRootVolumeDeleteOnTermination pulumi.BoolPtrInput `pulumi:"nodeRootVolumeDeleteOnTermination"`
	// Whether to encrypt a cluster node's root volume. Defaults to false.
	NodeRootVolumeEncrypted pulumi.BoolPtrInput `pulumi:"nodeRootVolumeEncrypted"`
	// The amount of provisioned IOPS. This is only valid with a volumeType of 'io1'.
	NodeRootVolumeIops pulumi.IntPtrInput `pulumi:"nodeRootVolumeIops"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize pulumi.IntPtrInput `pulumi:"nodeRootVolumeSize"`
	// Provisioned throughput performance in integer MiB/s for a cluster node's root volume. This is only valid with a volumeType of 'gp3'.
	NodeRootVolumeThroughput pulumi.IntPtrInput `pulumi:"nodeRootVolumeThroughput"`
	// Configured EBS type for a cluster node's root volume. Default is 'gp2'. Supported values are 'standard', 'gp2', 'gp3', 'st1', 'sc1', 'io1'.
	NodeRootVolumeType pulumi.StringPtrInput `pulumi:"nodeRootVolumeType"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup ec2.SecurityGroupInput `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds pulumi.StringArrayInput `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData pulumi.StringPtrInput `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride pulumi.StringPtrInput `pulumi:"nodeUserDataOverride"`
	// Extra nodeadm configuration sections to be added to the nodeadm user data. This can be shell scripts, nodeadm NodeConfig or any other user data compatible script. When configuring additional nodeadm NodeConfig sections, they'll be merged with the base settings the provider sets. You can overwrite base settings or provide additional settings this way.
	// The base settings the provider sets are:
	//   - cluster.name
	//   - cluster.apiServerEndpoint
	//   - cluster.certificateAuthority
	//   - cluster.cidr
	//
	// Note: This is only applicable when using AL2023.
	// See for more details:
	//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/
	//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/
	NodeadmExtraOptions NodeadmOptionsArrayInput `pulumi:"nodeadmExtraOptions"`
	// The type of OS to use for the node group. Will be used to determine the right EKS optimized AMI to use based on the instance types and gpu configuration.
	// Valid values are `AL2`, `AL2023` and `Bottlerocket`.
	//
	// Defaults to `AL2`.
	OperatingSystem OperatingSystemPtrInput `pulumi:"operatingSystem"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice pulumi.StringPtrInput `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints map[string]TaintArgs `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ClusterNodeGroupOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return i.ToClusterNodeGroupOptionsOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput)
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput).ToClusterNodeGroupOptionsPtrOutputWithContext(ctx)
}

// ClusterNodeGroupOptionsPtrInput is an input type that accepts ClusterNodeGroupOptionsArgs, ClusterNodeGroupOptionsPtr and ClusterNodeGroupOptionsPtrOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsPtrInput` via:
//
//	        ClusterNodeGroupOptionsArgs{...}
//
//	or:
//
//	        nil
type ClusterNodeGroupOptionsPtrInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput
	ToClusterNodeGroupOptionsPtrOutputWithContext(context.Context) ClusterNodeGroupOptionsPtrOutput
}

type clusterNodeGroupOptionsPtrType ClusterNodeGroupOptionsArgs

func ClusterNodeGroupOptionsPtr(v *ClusterNodeGroupOptionsArgs) ClusterNodeGroupOptionsPtrInput {
	return (*clusterNodeGroupOptionsPtrType)(v)
}

func (*clusterNodeGroupOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsPtrOutput)
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterNodeGroupOptions) *ClusterNodeGroupOptions {
		return &v
	}).(ClusterNodeGroupOptionsPtrOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.AmiId }).(pulumi.StringPtrOutput)
}

// The AMI Type to use for the worker nodes.
//
// Only applicable when setting an AMI ID that is of type `arm64`.
//
// Note: `amiType` and `gpu` are mutually exclusive.
func (o ClusterNodeGroupOptionsOutput) AmiType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.AmiType }).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.AutoScalingGroupTags }).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.BootstrapExtraArgs }).(pulumi.StringPtrOutput)
}

// The configuration settings for Bottlerocket OS.
// The settings will get merged with the base settings the provider uses to configure Bottlerocket.
//
// This includes:
//   - settings.kubernetes.api-server
//   - settings.kubernetes.cluster-certificate
//   - settings.kubernetes.cluster-name
//   - settings.kubernetes.cluster-dns-ip
//
// For an overview of the available settings, see https://bottlerocket.dev/en/os/1.20.x/api/settings/.
func (o ClusterNodeGroupOptionsOutput) BottlerocketSettings() pulumi.MapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]interface{} { return v.BottlerocketSettings }).(pulumi.MapOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.CloudFormationTags }).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroupRule { return v.ClusterIngressRule }).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.DesiredCapacity }).(pulumi.IntPtrOutput)
}

// Enables/disables detailed monitoring of the EC2 instances.
//
// With detailed monitoring, all metrics, including status check metrics, are available in 1-minute intervals.
// When enabled, you can also get aggregated data across groups of similar instances.
//
// Note: You are charged per metric that is sent to CloudWatch. You are not charged for data storage.
// For more information, see "Paid tier" and "Example 1 - EC2 Detailed Monitoring" here https://aws.amazon.com/cloudwatch/pricing/.
func (o ClusterNodeGroupOptionsOutput) EnableDetailedMonitoring() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.EnableDetailedMonitoring }).(pulumi.BoolPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.EncryptRootBlockDevice }).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.Gpu }).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *iam.InstanceProfile { return v.InstanceProfile }).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KubeletExtraArgs }).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MaxSize }).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MinSize }).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.NodeAssociatePublicIpAddress }).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodePublicKey }).(pulumi.StringPtrOutput)
}

// Whether the root block device should be deleted on termination of the instance. Defaults to true.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeDeleteOnTermination() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.NodeRootVolumeDeleteOnTermination }).(pulumi.BoolPtrOutput)
}

// Whether to encrypt a cluster node's root volume. Defaults to false.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeEncrypted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.NodeRootVolumeEncrypted }).(pulumi.BoolPtrOutput)
}

// The amount of provisioned IOPS. This is only valid with a volumeType of 'io1'.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeIops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.NodeRootVolumeIops }).(pulumi.IntPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.NodeRootVolumeSize }).(pulumi.IntPtrOutput)
}

// Provisioned throughput performance in integer MiB/s for a cluster node's root volume. This is only valid with a volumeType of 'gp3'.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.NodeRootVolumeThroughput }).(pulumi.IntPtrOutput)
}

// Configured EBS type for a cluster node's root volume. Default is 'gp2'. Supported values are 'standard', 'gp2', 'gp3', 'st1', 'sc1', 'io1'.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeRootVolumeType }).(pulumi.StringPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []string { return v.NodeSubnetIds }).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserData }).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserDataOverride }).(pulumi.StringPtrOutput)
}

// Extra nodeadm configuration sections to be added to the nodeadm user data. This can be shell scripts, nodeadm NodeConfig or any other user data compatible script. When configuring additional nodeadm NodeConfig sections, they'll be merged with the base settings the provider sets. You can overwrite base settings or provide additional settings this way.
// The base settings the provider sets are:
//   - cluster.name
//   - cluster.apiServerEndpoint
//   - cluster.certificateAuthority
//   - cluster.cidr
//
// Note: This is only applicable when using AL2023.
// See for more details:
//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/
//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/
func (o ClusterNodeGroupOptionsOutput) NodeadmExtraOptions() NodeadmOptionsArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []NodeadmOptions { return v.NodeadmExtraOptions }).(NodeadmOptionsArrayOutput)
}

// The type of OS to use for the node group. Will be used to determine the right EKS optimized AMI to use based on the instance types and gpu configuration.
// Valid values are `AL2`, `AL2023` and `Bottlerocket`.
//
// Defaults to `AL2`.
func (o ClusterNodeGroupOptionsOutput) OperatingSystem() OperatingSystemPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *OperatingSystem { return v.OperatingSystem }).(OperatingSystemPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.SpotPrice }).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]Taint { return v.Taints }).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ClusterNodeGroupOptionsPtrOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) Elem() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) ClusterNodeGroupOptions {
		if v != nil {
			return *v
		}
		var ret ClusterNodeGroupOptions
		return ret
	}).(ClusterNodeGroupOptionsOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsPtrOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.AmiId
	}).(pulumi.StringPtrOutput)
}

// The AMI Type to use for the worker nodes.
//
// Only applicable when setting an AMI ID that is of type `arm64`.
//
// Note: `amiType` and `gpu` are mutually exclusive.
func (o ClusterNodeGroupOptionsPtrOutput) AmiType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.AmiType
	}).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.AutoScalingGroupTags
	}).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsPtrOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.BootstrapExtraArgs
	}).(pulumi.StringPtrOutput)
}

// The configuration settings for Bottlerocket OS.
// The settings will get merged with the base settings the provider uses to configure Bottlerocket.
//
// This includes:
//   - settings.kubernetes.api-server
//   - settings.kubernetes.cluster-certificate
//   - settings.kubernetes.cluster-name
//   - settings.kubernetes.cluster-dns-ip
//
// For an overview of the available settings, see https://bottlerocket.dev/en/os/1.20.x/api/settings/.
func (o ClusterNodeGroupOptionsPtrOutput) BottlerocketSettings() pulumi.MapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.BottlerocketSettings
	}).(pulumi.MapOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.CloudFormationTags
	}).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroupRule {
		if v == nil {
			return nil
		}
		return v.ClusterIngressRule
	}).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.DesiredCapacity
	}).(pulumi.IntPtrOutput)
}

// Enables/disables detailed monitoring of the EC2 instances.
//
// With detailed monitoring, all metrics, including status check metrics, are available in 1-minute intervals.
// When enabled, you can also get aggregated data across groups of similar instances.
//
// Note: You are charged per metric that is sent to CloudWatch. You are not charged for data storage.
// For more information, see "Paid tier" and "Example 1 - EC2 Detailed Monitoring" here https://aws.amazon.com/cloudwatch/pricing/.
func (o ClusterNodeGroupOptionsPtrOutput) EnableDetailedMonitoring() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnableDetailedMonitoring
	}).(pulumi.BoolPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsPtrOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EncryptRootBlockDevice
	}).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsPtrOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.Gpu
	}).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *iam.InstanceProfile {
		if v == nil {
			return nil
		}
		return v.InstanceProfile
	}).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsPtrOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KubeletExtraArgs
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MinSize
	}).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsPtrOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodeAssociatePublicIpAddress
	}).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsPtrOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodePublicKey
	}).(pulumi.StringPtrOutput)
}

// Whether the root block device should be deleted on termination of the instance. Defaults to true.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeDeleteOnTermination() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeDeleteOnTermination
	}).(pulumi.BoolPtrOutput)
}

// Whether to encrypt a cluster node's root volume. Defaults to false.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeEncrypted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeEncrypted
	}).(pulumi.BoolPtrOutput)
}

// The amount of provisioned IOPS. This is only valid with a volumeType of 'io1'.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeIops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeIops
	}).(pulumi.IntPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeSize
	}).(pulumi.IntPtrOutput)
}

// Provisioned throughput performance in integer MiB/s for a cluster node's root volume. This is only valid with a volumeType of 'gp3'.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeThroughput
	}).(pulumi.IntPtrOutput)
}

// Configured EBS type for a cluster node's root volume. Default is 'gp2'. Supported values are 'standard', 'gp2', 'gp3', 'st1', 'sc1', 'io1'.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeType
	}).(pulumi.StringPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []string {
		if v == nil {
			return nil
		}
		return v.NodeSubnetIds
	}).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserData
	}).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserDataOverride
	}).(pulumi.StringPtrOutput)
}

// Extra nodeadm configuration sections to be added to the nodeadm user data. This can be shell scripts, nodeadm NodeConfig or any other user data compatible script. When configuring additional nodeadm NodeConfig sections, they'll be merged with the base settings the provider sets. You can overwrite base settings or provide additional settings this way.
// The base settings the provider sets are:
//   - cluster.name
//   - cluster.apiServerEndpoint
//   - cluster.certificateAuthority
//   - cluster.cidr
//
// Note: This is only applicable when using AL2023.
// See for more details:
//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/
//   - https://awslabs.github.io/amazon-eks-ami/nodeadm/doc/api/
func (o ClusterNodeGroupOptionsPtrOutput) NodeadmExtraOptions() NodeadmOptionsArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []NodeadmOptions {
		if v == nil {
			return nil
		}
		return v.NodeadmExtraOptions
	}).(NodeadmOptionsArrayOutput)
}

// The type of OS to use for the node group. Will be used to determine the right EKS optimized AMI to use based on the instance types and gpu configuration.
// Valid values are `AL2`, `AL2023` and `Bottlerocket`.
//
// Defaults to `AL2`.
func (o ClusterNodeGroupOptionsPtrOutput) OperatingSystem() OperatingSystemPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *OperatingSystem {
		if v == nil {
			return nil
		}
		return v.OperatingSystem
	}).(OperatingSystemPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsPtrOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.SpotPrice
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsPtrOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]Taint {
		if v == nil {
			return nil
		}
		return v.Taints
	}).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreData struct {
	// The access entries added to the cluster.
	AccessEntries []AccessEntry `pulumi:"accessEntries"`
	AwsProvider   *aws.Provider `pulumi:"awsProvider"`
	Cluster       *eks.Cluster  `pulumi:"cluster"`
	// The IAM Role attached to the EKS Cluster
	ClusterIamRole       *iam.Role                    `pulumi:"clusterIamRole"`
	ClusterSecurityGroup *ec2.SecurityGroup           `pulumi:"clusterSecurityGroup"`
	EksNodeAccess        *corev1.ConfigMap            `pulumi:"eksNodeAccess"`
	EncryptionConfig     *eks.ClusterEncryptionConfig `pulumi:"encryptionConfig"`
	// The EKS cluster's Kubernetes API server endpoint.
	Endpoint string `pulumi:"endpoint"`
	// The Fargate profile used to manage which pods run on Fargate.
	FargateProfile *eks.FargateProfile `pulumi:"fargateProfile"`
	// The IAM instance roles for the cluster's nodes.
	InstanceRoles []*iam.Role `pulumi:"instanceRoles"`
	// The kubeconfig file for the cluster.
	Kubeconfig interface{} `pulumi:"kubeconfig"`
	// The cluster's node group options.
	NodeGroupOptions ClusterNodeGroupOptions `pulumi:"nodeGroupOptions"`
	// Tags attached to the security groups associated with the cluster's worker nodes.
	NodeSecurityGroupTags map[string]string          `pulumi:"nodeSecurityGroupTags"`
	OidcProvider          *iam.OpenIdConnectProvider `pulumi:"oidcProvider"`
	// List of subnet IDs for the private subnets.
	PrivateSubnetIds []string             `pulumi:"privateSubnetIds"`
	Provider         *kubernetes.Provider `pulumi:"provider"`
	// List of subnet IDs for the public subnets.
	PublicSubnetIds []string `pulumi:"publicSubnetIds"`
	// The storage class used for persistent storage by the cluster.
	StorageClasses map[string]*storagev1.StorageClass `pulumi:"storageClasses"`
	// List of subnet IDs for the EKS cluster.
	SubnetIds []string `pulumi:"subnetIds"`
	// A map of tags assigned to the EKS cluster.
	Tags map[string]string `pulumi:"tags"`
	// The VPC CNI for the cluster.
	VpcCni *VpcCni `pulumi:"vpcCni"`
	// ID of the cluster's VPC.
	VpcId string `pulumi:"vpcId"`
}

// CoreDataInput is an input type that accepts CoreDataArgs and CoreDataOutput values.
// You can construct a concrete instance of `CoreDataInput` via:
//
//	CoreDataArgs{...}
type CoreDataInput interface {
	pulumi.Input

	ToCoreDataOutput() CoreDataOutput
	ToCoreDataOutputWithContext(context.Context) CoreDataOutput
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreDataArgs struct {
	// The access entries added to the cluster.
	AccessEntries AccessEntryArrayInput `pulumi:"accessEntries"`
	AwsProvider   aws.ProviderInput     `pulumi:"awsProvider"`
	Cluster       eks.ClusterInput      `pulumi:"cluster"`
	// The IAM Role attached to the EKS Cluster
	ClusterIamRole       iam.RoleInput                       `pulumi:"clusterIamRole"`
	ClusterSecurityGroup ec2.SecurityGroupInput              `pulumi:"clusterSecurityGroup"`
	EksNodeAccess        corev1.ConfigMapInput               `pulumi:"eksNodeAccess"`
	EncryptionConfig     eks.ClusterEncryptionConfigPtrInput `pulumi:"encryptionConfig"`
	// The EKS cluster's Kubernetes API server endpoint.
	Endpoint pulumi.StringInput `pulumi:"endpoint"`
	// The Fargate profile used to manage which pods run on Fargate.
	FargateProfile eks.FargateProfileInput `pulumi:"fargateProfile"`
	// The IAM instance roles for the cluster's nodes.
	InstanceRoles iam.RoleArrayInput `pulumi:"instanceRoles"`
	// The kubeconfig file for the cluster.
	Kubeconfig pulumi.Input `pulumi:"kubeconfig"`
	// The cluster's node group options.
	NodeGroupOptions ClusterNodeGroupOptionsInput `pulumi:"nodeGroupOptions"`
	// Tags attached to the security groups associated with the cluster's worker nodes.
	NodeSecurityGroupTags pulumi.StringMapInput          `pulumi:"nodeSecurityGroupTags"`
	OidcProvider          iam.OpenIdConnectProviderInput `pulumi:"oidcProvider"`
	// List of subnet IDs for the private subnets.
	PrivateSubnetIds pulumi.StringArrayInput  `pulumi:"privateSubnetIds"`
	Provider         kubernetes.ProviderInput `pulumi:"provider"`
	// List of subnet IDs for the public subnets.
	PublicSubnetIds pulumi.StringArrayInput `pulumi:"publicSubnetIds"`
	// The storage class used for persistent storage by the cluster.
	StorageClasses storagev1.StorageClassMapInput `pulumi:"storageClasses"`
	// List of subnet IDs for the EKS cluster.
	SubnetIds pulumi.StringArrayInput `pulumi:"subnetIds"`
	// A map of tags assigned to the EKS cluster.
	Tags pulumi.StringMapInput `pulumi:"tags"`
	// The VPC CNI for the cluster.
	VpcCni VpcCniInput `pulumi:"vpcCni"`
	// ID of the cluster's VPC.
	VpcId pulumi.StringInput `pulumi:"vpcId"`
}

func (CoreDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreData)(nil)).Elem()
}

func (i CoreDataArgs) ToCoreDataOutput() CoreDataOutput {
	return i.ToCoreDataOutputWithContext(context.Background())
}

func (i CoreDataArgs) ToCoreDataOutputWithContext(ctx context.Context) CoreDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDataOutput)
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreDataOutput struct{ *pulumi.OutputState }

func (CoreDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreData)(nil)).Elem()
}

func (o CoreDataOutput) ToCoreDataOutput() CoreDataOutput {
	return o
}

func (o CoreDataOutput) ToCoreDataOutputWithContext(ctx context.Context) CoreDataOutput {
	return o
}

// The access entries added to the cluster.
func (o CoreDataOutput) AccessEntries() AccessEntryArrayOutput {
	return o.ApplyT(func(v CoreData) []AccessEntry { return v.AccessEntries }).(AccessEntryArrayOutput)
}

func (o CoreDataOutput) AwsProvider() aws.ProviderOutput {
	return o.ApplyT(func(v CoreData) *aws.Provider { return v.AwsProvider }).(aws.ProviderOutput)
}

func (o CoreDataOutput) Cluster() eks.ClusterOutput {
	return o.ApplyT(func(v CoreData) *eks.Cluster { return v.Cluster }).(eks.ClusterOutput)
}

// The IAM Role attached to the EKS Cluster
func (o CoreDataOutput) ClusterIamRole() iam.RoleOutput {
	return o.ApplyT(func(v CoreData) *iam.Role { return v.ClusterIamRole }).(iam.RoleOutput)
}

func (o CoreDataOutput) ClusterSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v CoreData) *ec2.SecurityGroup { return v.ClusterSecurityGroup }).(ec2.SecurityGroupOutput)
}

func (o CoreDataOutput) EksNodeAccess() corev1.ConfigMapOutput {
	return o.ApplyT(func(v CoreData) *corev1.ConfigMap { return v.EksNodeAccess }).(corev1.ConfigMapOutput)
}

func (o CoreDataOutput) EncryptionConfig() eks.ClusterEncryptionConfigPtrOutput {
	return o.ApplyT(func(v CoreData) *eks.ClusterEncryptionConfig { return v.EncryptionConfig }).(eks.ClusterEncryptionConfigPtrOutput)
}

// The EKS cluster's Kubernetes API server endpoint.
func (o CoreDataOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.Endpoint }).(pulumi.StringOutput)
}

// The Fargate profile used to manage which pods run on Fargate.
func (o CoreDataOutput) FargateProfile() eks.FargateProfileOutput {
	return o.ApplyT(func(v CoreData) *eks.FargateProfile { return v.FargateProfile }).(eks.FargateProfileOutput)
}

// The IAM instance roles for the cluster's nodes.
func (o CoreDataOutput) InstanceRoles() iam.RoleArrayOutput {
	return o.ApplyT(func(v CoreData) []*iam.Role { return v.InstanceRoles }).(iam.RoleArrayOutput)
}

// The kubeconfig file for the cluster.
func (o CoreDataOutput) Kubeconfig() pulumi.AnyOutput {
	return o.ApplyT(func(v CoreData) interface{} { return v.Kubeconfig }).(pulumi.AnyOutput)
}

// The cluster's node group options.
func (o CoreDataOutput) NodeGroupOptions() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v CoreData) ClusterNodeGroupOptions { return v.NodeGroupOptions }).(ClusterNodeGroupOptionsOutput)
}

// Tags attached to the security groups associated with the cluster's worker nodes.
func (o CoreDataOutput) NodeSecurityGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.NodeSecurityGroupTags }).(pulumi.StringMapOutput)
}

func (o CoreDataOutput) OidcProvider() iam.OpenIdConnectProviderOutput {
	return o.ApplyT(func(v CoreData) *iam.OpenIdConnectProvider { return v.OidcProvider }).(iam.OpenIdConnectProviderOutput)
}

// List of subnet IDs for the private subnets.
func (o CoreDataOutput) PrivateSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PrivateSubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) Provider() kubernetes.ProviderOutput {
	return o.ApplyT(func(v CoreData) *kubernetes.Provider { return v.Provider }).(kubernetes.ProviderOutput)
}

// List of subnet IDs for the public subnets.
func (o CoreDataOutput) PublicSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PublicSubnetIds }).(pulumi.StringArrayOutput)
}

// The storage class used for persistent storage by the cluster.
func (o CoreDataOutput) StorageClasses() storagev1.StorageClassMapOutput {
	return o.ApplyT(func(v CoreData) map[string]*storagev1.StorageClass { return v.StorageClasses }).(storagev1.StorageClassMapOutput)
}

// List of subnet IDs for the EKS cluster.
func (o CoreDataOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

// A map of tags assigned to the EKS cluster.
func (o CoreDataOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

// The VPC CNI for the cluster.
func (o CoreDataOutput) VpcCni() VpcCniOutput {
	return o.ApplyT(func(v CoreData) *VpcCni { return v.VpcCni }).(VpcCniOutput)
}

// ID of the cluster's VPC.
func (o CoreDataOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.VpcId }).(pulumi.StringOutput)
}

type CoreDnsAddonOptions struct {
	// Whether or not to create the Addon in the cluster
	Enabled *bool `pulumi:"enabled"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate `pulumi:"resolveConflictsOnUpdate"`
	// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
	Version *string `pulumi:"version"`
}

// Defaults sets the appropriate defaults for CoreDnsAddonOptions
func (val *CoreDnsAddonOptions) Defaults() *CoreDnsAddonOptions {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Enabled == nil {
		enabled_ := true
		tmp.Enabled = &enabled_
	}
	if tmp.ResolveConflictsOnCreate == nil {
		resolveConflictsOnCreate_ := ResolveConflictsOnCreate("OVERWRITE")
		tmp.ResolveConflictsOnCreate = &resolveConflictsOnCreate_
	}
	if tmp.ResolveConflictsOnUpdate == nil {
		resolveConflictsOnUpdate_ := ResolveConflictsOnUpdate("OVERWRITE")
		tmp.ResolveConflictsOnUpdate = &resolveConflictsOnUpdate_
	}
	return &tmp
}

// CoreDnsAddonOptionsInput is an input type that accepts CoreDnsAddonOptionsArgs and CoreDnsAddonOptionsOutput values.
// You can construct a concrete instance of `CoreDnsAddonOptionsInput` via:
//
//	CoreDnsAddonOptionsArgs{...}
type CoreDnsAddonOptionsInput interface {
	pulumi.Input

	ToCoreDnsAddonOptionsOutput() CoreDnsAddonOptionsOutput
	ToCoreDnsAddonOptionsOutputWithContext(context.Context) CoreDnsAddonOptionsOutput
}

type CoreDnsAddonOptionsArgs struct {
	// Whether or not to create the Addon in the cluster
	Enabled *bool `pulumi:"enabled"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate `pulumi:"resolveConflictsOnUpdate"`
	// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
	Version pulumi.StringPtrInput `pulumi:"version"`
}

// Defaults sets the appropriate defaults for CoreDnsAddonOptionsArgs
func (val *CoreDnsAddonOptionsArgs) Defaults() *CoreDnsAddonOptionsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Enabled == nil {
		enabled_ := true
		tmp.Enabled = &enabled_
	}
	if tmp.ResolveConflictsOnCreate == nil {
		resolveConflictsOnCreate_ := ResolveConflictsOnCreate("OVERWRITE")
		tmp.ResolveConflictsOnCreate = &resolveConflictsOnCreate_
	}
	if tmp.ResolveConflictsOnUpdate == nil {
		resolveConflictsOnUpdate_ := ResolveConflictsOnUpdate("OVERWRITE")
		tmp.ResolveConflictsOnUpdate = &resolveConflictsOnUpdate_
	}
	return &tmp
}
func (CoreDnsAddonOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDnsAddonOptions)(nil)).Elem()
}

func (i CoreDnsAddonOptionsArgs) ToCoreDnsAddonOptionsOutput() CoreDnsAddonOptionsOutput {
	return i.ToCoreDnsAddonOptionsOutputWithContext(context.Background())
}

func (i CoreDnsAddonOptionsArgs) ToCoreDnsAddonOptionsOutputWithContext(ctx context.Context) CoreDnsAddonOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDnsAddonOptionsOutput)
}

func (i CoreDnsAddonOptionsArgs) ToCoreDnsAddonOptionsPtrOutput() CoreDnsAddonOptionsPtrOutput {
	return i.ToCoreDnsAddonOptionsPtrOutputWithContext(context.Background())
}

func (i CoreDnsAddonOptionsArgs) ToCoreDnsAddonOptionsPtrOutputWithContext(ctx context.Context) CoreDnsAddonOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDnsAddonOptionsOutput).ToCoreDnsAddonOptionsPtrOutputWithContext(ctx)
}

// CoreDnsAddonOptionsPtrInput is an input type that accepts CoreDnsAddonOptionsArgs, CoreDnsAddonOptionsPtr and CoreDnsAddonOptionsPtrOutput values.
// You can construct a concrete instance of `CoreDnsAddonOptionsPtrInput` via:
//
//	        CoreDnsAddonOptionsArgs{...}
//
//	or:
//
//	        nil
type CoreDnsAddonOptionsPtrInput interface {
	pulumi.Input

	ToCoreDnsAddonOptionsPtrOutput() CoreDnsAddonOptionsPtrOutput
	ToCoreDnsAddonOptionsPtrOutputWithContext(context.Context) CoreDnsAddonOptionsPtrOutput
}

type coreDnsAddonOptionsPtrType CoreDnsAddonOptionsArgs

func CoreDnsAddonOptionsPtr(v *CoreDnsAddonOptionsArgs) CoreDnsAddonOptionsPtrInput {
	return (*coreDnsAddonOptionsPtrType)(v)
}

func (*coreDnsAddonOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDnsAddonOptions)(nil)).Elem()
}

func (i *coreDnsAddonOptionsPtrType) ToCoreDnsAddonOptionsPtrOutput() CoreDnsAddonOptionsPtrOutput {
	return i.ToCoreDnsAddonOptionsPtrOutputWithContext(context.Background())
}

func (i *coreDnsAddonOptionsPtrType) ToCoreDnsAddonOptionsPtrOutputWithContext(ctx context.Context) CoreDnsAddonOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDnsAddonOptionsPtrOutput)
}

type CoreDnsAddonOptionsOutput struct{ *pulumi.OutputState }

func (CoreDnsAddonOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDnsAddonOptions)(nil)).Elem()
}

func (o CoreDnsAddonOptionsOutput) ToCoreDnsAddonOptionsOutput() CoreDnsAddonOptionsOutput {
	return o
}

func (o CoreDnsAddonOptionsOutput) ToCoreDnsAddonOptionsOutputWithContext(ctx context.Context) CoreDnsAddonOptionsOutput {
	return o
}

func (o CoreDnsAddonOptionsOutput) ToCoreDnsAddonOptionsPtrOutput() CoreDnsAddonOptionsPtrOutput {
	return o.ToCoreDnsAddonOptionsPtrOutputWithContext(context.Background())
}

func (o CoreDnsAddonOptionsOutput) ToCoreDnsAddonOptionsPtrOutputWithContext(ctx context.Context) CoreDnsAddonOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDnsAddonOptions) *CoreDnsAddonOptions {
		return &v
	}).(CoreDnsAddonOptionsPtrOutput)
}

// Whether or not to create the Addon in the cluster
func (o CoreDnsAddonOptionsOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDnsAddonOptions) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
func (o CoreDnsAddonOptionsOutput) ResolveConflictsOnCreate() ResolveConflictsOnCreatePtrOutput {
	return o.ApplyT(func(v CoreDnsAddonOptions) *ResolveConflictsOnCreate { return v.ResolveConflictsOnCreate }).(ResolveConflictsOnCreatePtrOutput)
}

// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
func (o CoreDnsAddonOptionsOutput) ResolveConflictsOnUpdate() ResolveConflictsOnUpdatePtrOutput {
	return o.ApplyT(func(v CoreDnsAddonOptions) *ResolveConflictsOnUpdate { return v.ResolveConflictsOnUpdate }).(ResolveConflictsOnUpdatePtrOutput)
}

// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
func (o CoreDnsAddonOptionsOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDnsAddonOptions) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type CoreDnsAddonOptionsPtrOutput struct{ *pulumi.OutputState }

func (CoreDnsAddonOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDnsAddonOptions)(nil)).Elem()
}

func (o CoreDnsAddonOptionsPtrOutput) ToCoreDnsAddonOptionsPtrOutput() CoreDnsAddonOptionsPtrOutput {
	return o
}

func (o CoreDnsAddonOptionsPtrOutput) ToCoreDnsAddonOptionsPtrOutputWithContext(ctx context.Context) CoreDnsAddonOptionsPtrOutput {
	return o
}

func (o CoreDnsAddonOptionsPtrOutput) Elem() CoreDnsAddonOptionsOutput {
	return o.ApplyT(func(v *CoreDnsAddonOptions) CoreDnsAddonOptions {
		if v != nil {
			return *v
		}
		var ret CoreDnsAddonOptions
		return ret
	}).(CoreDnsAddonOptionsOutput)
}

// Whether or not to create the Addon in the cluster
func (o CoreDnsAddonOptionsPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDnsAddonOptions) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
func (o CoreDnsAddonOptionsPtrOutput) ResolveConflictsOnCreate() ResolveConflictsOnCreatePtrOutput {
	return o.ApplyT(func(v *CoreDnsAddonOptions) *ResolveConflictsOnCreate {
		if v == nil {
			return nil
		}
		return v.ResolveConflictsOnCreate
	}).(ResolveConflictsOnCreatePtrOutput)
}

// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
func (o CoreDnsAddonOptionsPtrOutput) ResolveConflictsOnUpdate() ResolveConflictsOnUpdatePtrOutput {
	return o.ApplyT(func(v *CoreDnsAddonOptions) *ResolveConflictsOnUpdate {
		if v == nil {
			return nil
		}
		return v.ResolveConflictsOnUpdate
	}).(ResolveConflictsOnUpdatePtrOutput)
}

// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
func (o CoreDnsAddonOptionsPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDnsAddonOptions) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
//
// Note: This option is only supported with Pulumi nodejs programs. Please use `ProviderCredentialOpts` as an alternative instead.
type CreationRoleProvider struct {
	Provider *aws.Provider `pulumi:"provider"`
	Role     *iam.Role     `pulumi:"role"`
}

// CreationRoleProviderInput is an input type that accepts CreationRoleProviderArgs and CreationRoleProviderOutput values.
// You can construct a concrete instance of `CreationRoleProviderInput` via:
//
//	CreationRoleProviderArgs{...}
type CreationRoleProviderInput interface {
	pulumi.Input

	ToCreationRoleProviderOutput() CreationRoleProviderOutput
	ToCreationRoleProviderOutputWithContext(context.Context) CreationRoleProviderOutput
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
//
// Note: This option is only supported with Pulumi nodejs programs. Please use `ProviderCredentialOpts` as an alternative instead.
type CreationRoleProviderArgs struct {
	Provider *aws.Provider `pulumi:"provider"`
	Role     *iam.Role     `pulumi:"role"`
}

func (CreationRoleProviderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return i.ToCreationRoleProviderOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput)
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput).ToCreationRoleProviderPtrOutputWithContext(ctx)
}

// CreationRoleProviderPtrInput is an input type that accepts CreationRoleProviderArgs, CreationRoleProviderPtr and CreationRoleProviderPtrOutput values.
// You can construct a concrete instance of `CreationRoleProviderPtrInput` via:
//
//	        CreationRoleProviderArgs{...}
//
//	or:
//
//	        nil
type CreationRoleProviderPtrInput interface {
	pulumi.Input

	ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput
	ToCreationRoleProviderPtrOutputWithContext(context.Context) CreationRoleProviderPtrOutput
}

type creationRoleProviderPtrType CreationRoleProviderArgs

func CreationRoleProviderPtr(v *CreationRoleProviderArgs) CreationRoleProviderPtrInput {
	return (*creationRoleProviderPtrType)(v)
}

func (*creationRoleProviderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderPtrOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
//
// Note: This option is only supported with Pulumi nodejs programs. Please use `ProviderCredentialOpts` as an alternative instead.
type CreationRoleProviderOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CreationRoleProvider) *CreationRoleProvider {
		return &v
	}).(CreationRoleProviderPtrOutput)
}

func (o CreationRoleProviderOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v CreationRoleProvider) *aws.Provider { return v.Provider }).(aws.ProviderOutput)
}

func (o CreationRoleProviderOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v CreationRoleProvider) *iam.Role { return v.Role }).(iam.RoleOutput)
}

type CreationRoleProviderPtrOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) Elem() CreationRoleProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) CreationRoleProvider {
		if v != nil {
			return *v
		}
		var ret CreationRoleProvider
		return ret
	}).(CreationRoleProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *aws.Provider {
		if v == nil {
			return nil
		}
		return v.Provider
	}).(aws.ProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *iam.Role {
		if v == nil {
			return nil
		}
		return v.Role
	}).(iam.RoleOutput)
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfile struct {
	// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
	PodExecutionRoleArn *string `pulumi:"podExecutionRoleArn"`
	// Specify the namespace and label selectors to use for launching pods into Fargate.
	Selectors []eks.FargateProfileSelector `pulumi:"selectors"`
	// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
	SubnetIds []string `pulumi:"subnetIds"`
}

// FargateProfileInput is an input type that accepts FargateProfileArgs and FargateProfileOutput values.
// You can construct a concrete instance of `FargateProfileInput` via:
//
//	FargateProfileArgs{...}
type FargateProfileInput interface {
	pulumi.Input

	ToFargateProfileOutput() FargateProfileOutput
	ToFargateProfileOutputWithContext(context.Context) FargateProfileOutput
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfileArgs struct {
	// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
	PodExecutionRoleArn pulumi.StringPtrInput `pulumi:"podExecutionRoleArn"`
	// Specify the namespace and label selectors to use for launching pods into Fargate.
	Selectors eks.FargateProfileSelectorArrayInput `pulumi:"selectors"`
	// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
	SubnetIds pulumi.StringArrayInput `pulumi:"subnetIds"`
}

func (FargateProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FargateProfile)(nil)).Elem()
}

func (i FargateProfileArgs) ToFargateProfileOutput() FargateProfileOutput {
	return i.ToFargateProfileOutputWithContext(context.Background())
}

func (i FargateProfileArgs) ToFargateProfileOutputWithContext(ctx context.Context) FargateProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateProfileOutput)
}

func (i FargateProfileArgs) ToFargateProfilePtrOutput() FargateProfilePtrOutput {
	return i.ToFargateProfilePtrOutputWithContext(context.Background())
}

func (i FargateProfileArgs) ToFargateProfilePtrOutputWithContext(ctx context.Context) FargateProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateProfileOutput).ToFargateProfilePtrOutputWithContext(ctx)
}

// FargateProfilePtrInput is an input type that accepts FargateProfileArgs, FargateProfilePtr and FargateProfilePtrOutput values.
// You can construct a concrete instance of `FargateProfilePtrInput` via:
//
//	        FargateProfileArgs{...}
//
//	or:
//
//	        nil
type FargateProfilePtrInput interface {
	pulumi.Input

	ToFargateProfilePtrOutput() FargateProfilePtrOutput
	ToFargateProfilePtrOutputWithContext(context.Context) FargateProfilePtrOutput
}

type fargateProfilePtrType FargateProfileArgs

func FargateProfilePtr(v *FargateProfileArgs) FargateProfilePtrInput {
	return (*fargateProfilePtrType)(v)
}

func (*fargateProfilePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FargateProfile)(nil)).Elem()
}

func (i *fargateProfilePtrType) ToFargateProfilePtrOutput() FargateProfilePtrOutput {
	return i.ToFargateProfilePtrOutputWithContext(context.Background())
}

func (i *fargateProfilePtrType) ToFargateProfilePtrOutputWithContext(ctx context.Context) FargateProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateProfilePtrOutput)
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfileOutput struct{ *pulumi.OutputState }

func (FargateProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FargateProfile)(nil)).Elem()
}

func (o FargateProfileOutput) ToFargateProfileOutput() FargateProfileOutput {
	return o
}

func (o FargateProfileOutput) ToFargateProfileOutputWithContext(ctx context.Context) FargateProfileOutput {
	return o
}

func (o FargateProfileOutput) ToFargateProfilePtrOutput() FargateProfilePtrOutput {
	return o.ToFargateProfilePtrOutputWithContext(context.Background())
}

func (o FargateProfileOutput) ToFargateProfilePtrOutputWithContext(ctx context.Context) FargateProfilePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FargateProfile) *FargateProfile {
		return &v
	}).(FargateProfilePtrOutput)
}

// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
func (o FargateProfileOutput) PodExecutionRoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FargateProfile) *string { return v.PodExecutionRoleArn }).(pulumi.StringPtrOutput)
}

// Specify the namespace and label selectors to use for launching pods into Fargate.
func (o FargateProfileOutput) Selectors() eks.FargateProfileSelectorArrayOutput {
	return o.ApplyT(func(v FargateProfile) []eks.FargateProfileSelector { return v.Selectors }).(eks.FargateProfileSelectorArrayOutput)
}

// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
func (o FargateProfileOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FargateProfile) []string { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

type FargateProfilePtrOutput struct{ *pulumi.OutputState }

func (FargateProfilePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FargateProfile)(nil)).Elem()
}

func (o FargateProfilePtrOutput) ToFargateProfilePtrOutput() FargateProfilePtrOutput {
	return o
}

func (o FargateProfilePtrOutput) ToFargateProfilePtrOutputWithContext(ctx context.Context) FargateProfilePtrOutput {
	return o
}

func (o FargateProfilePtrOutput) Elem() FargateProfileOutput {
	return o.ApplyT(func(v *FargateProfile) FargateProfile {
		if v != nil {
			return *v
		}
		var ret FargateProfile
		return ret
	}).(FargateProfileOutput)
}

// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
func (o FargateProfilePtrOutput) PodExecutionRoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FargateProfile) *string {
		if v == nil {
			return nil
		}
		return v.PodExecutionRoleArn
	}).(pulumi.StringPtrOutput)
}

// Specify the namespace and label selectors to use for launching pods into Fargate.
func (o FargateProfilePtrOutput) Selectors() eks.FargateProfileSelectorArrayOutput {
	return o.ApplyT(func(v *FargateProfile) []eks.FargateProfileSelector {
		if v == nil {
			return nil
		}
		return v.Selectors
	}).(eks.FargateProfileSelectorArrayOutput)
}

// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
func (o FargateProfilePtrOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FargateProfile) []string {
		if v == nil {
			return nil
		}
		return v.SubnetIds
	}).(pulumi.StringArrayOutput)
}

type KubeProxyAddonOptions struct {
	// Whether or not to create the `kube-proxy` Addon in the cluster
	Enabled *bool `pulumi:"enabled"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate `pulumi:"resolveConflictsOnUpdate"`
	// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
	Version *string `pulumi:"version"`
}

// Defaults sets the appropriate defaults for KubeProxyAddonOptions
func (val *KubeProxyAddonOptions) Defaults() *KubeProxyAddonOptions {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Enabled == nil {
		enabled_ := true
		tmp.Enabled = &enabled_
	}
	if tmp.ResolveConflictsOnCreate == nil {
		resolveConflictsOnCreate_ := ResolveConflictsOnCreate("OVERWRITE")
		tmp.ResolveConflictsOnCreate = &resolveConflictsOnCreate_
	}
	if tmp.ResolveConflictsOnUpdate == nil {
		resolveConflictsOnUpdate_ := ResolveConflictsOnUpdate("OVERWRITE")
		tmp.ResolveConflictsOnUpdate = &resolveConflictsOnUpdate_
	}
	return &tmp
}

// KubeProxyAddonOptionsInput is an input type that accepts KubeProxyAddonOptionsArgs and KubeProxyAddonOptionsOutput values.
// You can construct a concrete instance of `KubeProxyAddonOptionsInput` via:
//
//	KubeProxyAddonOptionsArgs{...}
type KubeProxyAddonOptionsInput interface {
	pulumi.Input

	ToKubeProxyAddonOptionsOutput() KubeProxyAddonOptionsOutput
	ToKubeProxyAddonOptionsOutputWithContext(context.Context) KubeProxyAddonOptionsOutput
}

type KubeProxyAddonOptionsArgs struct {
	// Whether or not to create the `kube-proxy` Addon in the cluster
	Enabled *bool `pulumi:"enabled"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate `pulumi:"resolveConflictsOnUpdate"`
	// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
	Version pulumi.StringPtrInput `pulumi:"version"`
}

// Defaults sets the appropriate defaults for KubeProxyAddonOptionsArgs
func (val *KubeProxyAddonOptionsArgs) Defaults() *KubeProxyAddonOptionsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Enabled == nil {
		enabled_ := true
		tmp.Enabled = &enabled_
	}
	if tmp.ResolveConflictsOnCreate == nil {
		resolveConflictsOnCreate_ := ResolveConflictsOnCreate("OVERWRITE")
		tmp.ResolveConflictsOnCreate = &resolveConflictsOnCreate_
	}
	if tmp.ResolveConflictsOnUpdate == nil {
		resolveConflictsOnUpdate_ := ResolveConflictsOnUpdate("OVERWRITE")
		tmp.ResolveConflictsOnUpdate = &resolveConflictsOnUpdate_
	}
	return &tmp
}
func (KubeProxyAddonOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeProxyAddonOptions)(nil)).Elem()
}

func (i KubeProxyAddonOptionsArgs) ToKubeProxyAddonOptionsOutput() KubeProxyAddonOptionsOutput {
	return i.ToKubeProxyAddonOptionsOutputWithContext(context.Background())
}

func (i KubeProxyAddonOptionsArgs) ToKubeProxyAddonOptionsOutputWithContext(ctx context.Context) KubeProxyAddonOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeProxyAddonOptionsOutput)
}

func (i KubeProxyAddonOptionsArgs) ToKubeProxyAddonOptionsPtrOutput() KubeProxyAddonOptionsPtrOutput {
	return i.ToKubeProxyAddonOptionsPtrOutputWithContext(context.Background())
}

func (i KubeProxyAddonOptionsArgs) ToKubeProxyAddonOptionsPtrOutputWithContext(ctx context.Context) KubeProxyAddonOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeProxyAddonOptionsOutput).ToKubeProxyAddonOptionsPtrOutputWithContext(ctx)
}

// KubeProxyAddonOptionsPtrInput is an input type that accepts KubeProxyAddonOptionsArgs, KubeProxyAddonOptionsPtr and KubeProxyAddonOptionsPtrOutput values.
// You can construct a concrete instance of `KubeProxyAddonOptionsPtrInput` via:
//
//	        KubeProxyAddonOptionsArgs{...}
//
//	or:
//
//	        nil
type KubeProxyAddonOptionsPtrInput interface {
	pulumi.Input

	ToKubeProxyAddonOptionsPtrOutput() KubeProxyAddonOptionsPtrOutput
	ToKubeProxyAddonOptionsPtrOutputWithContext(context.Context) KubeProxyAddonOptionsPtrOutput
}

type kubeProxyAddonOptionsPtrType KubeProxyAddonOptionsArgs

func KubeProxyAddonOptionsPtr(v *KubeProxyAddonOptionsArgs) KubeProxyAddonOptionsPtrInput {
	return (*kubeProxyAddonOptionsPtrType)(v)
}

func (*kubeProxyAddonOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeProxyAddonOptions)(nil)).Elem()
}

func (i *kubeProxyAddonOptionsPtrType) ToKubeProxyAddonOptionsPtrOutput() KubeProxyAddonOptionsPtrOutput {
	return i.ToKubeProxyAddonOptionsPtrOutputWithContext(context.Background())
}

func (i *kubeProxyAddonOptionsPtrType) ToKubeProxyAddonOptionsPtrOutputWithContext(ctx context.Context) KubeProxyAddonOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeProxyAddonOptionsPtrOutput)
}

type KubeProxyAddonOptionsOutput struct{ *pulumi.OutputState }

func (KubeProxyAddonOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeProxyAddonOptions)(nil)).Elem()
}

func (o KubeProxyAddonOptionsOutput) ToKubeProxyAddonOptionsOutput() KubeProxyAddonOptionsOutput {
	return o
}

func (o KubeProxyAddonOptionsOutput) ToKubeProxyAddonOptionsOutputWithContext(ctx context.Context) KubeProxyAddonOptionsOutput {
	return o
}

func (o KubeProxyAddonOptionsOutput) ToKubeProxyAddonOptionsPtrOutput() KubeProxyAddonOptionsPtrOutput {
	return o.ToKubeProxyAddonOptionsPtrOutputWithContext(context.Background())
}

func (o KubeProxyAddonOptionsOutput) ToKubeProxyAddonOptionsPtrOutputWithContext(ctx context.Context) KubeProxyAddonOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KubeProxyAddonOptions) *KubeProxyAddonOptions {
		return &v
	}).(KubeProxyAddonOptionsPtrOutput)
}

// Whether or not to create the `kube-proxy` Addon in the cluster
func (o KubeProxyAddonOptionsOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KubeProxyAddonOptions) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
func (o KubeProxyAddonOptionsOutput) ResolveConflictsOnCreate() ResolveConflictsOnCreatePtrOutput {
	return o.ApplyT(func(v KubeProxyAddonOptions) *ResolveConflictsOnCreate { return v.ResolveConflictsOnCreate }).(ResolveConflictsOnCreatePtrOutput)
}

// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
func (o KubeProxyAddonOptionsOutput) ResolveConflictsOnUpdate() ResolveConflictsOnUpdatePtrOutput {
	return o.ApplyT(func(v KubeProxyAddonOptions) *ResolveConflictsOnUpdate { return v.ResolveConflictsOnUpdate }).(ResolveConflictsOnUpdatePtrOutput)
}

// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
func (o KubeProxyAddonOptionsOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeProxyAddonOptions) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type KubeProxyAddonOptionsPtrOutput struct{ *pulumi.OutputState }

func (KubeProxyAddonOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeProxyAddonOptions)(nil)).Elem()
}

func (o KubeProxyAddonOptionsPtrOutput) ToKubeProxyAddonOptionsPtrOutput() KubeProxyAddonOptionsPtrOutput {
	return o
}

func (o KubeProxyAddonOptionsPtrOutput) ToKubeProxyAddonOptionsPtrOutputWithContext(ctx context.Context) KubeProxyAddonOptionsPtrOutput {
	return o
}

func (o KubeProxyAddonOptionsPtrOutput) Elem() KubeProxyAddonOptionsOutput {
	return o.ApplyT(func(v *KubeProxyAddonOptions) KubeProxyAddonOptions {
		if v != nil {
			return *v
		}
		var ret KubeProxyAddonOptions
		return ret
	}).(KubeProxyAddonOptionsOutput)
}

// Whether or not to create the `kube-proxy` Addon in the cluster
func (o KubeProxyAddonOptionsPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KubeProxyAddonOptions) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
func (o KubeProxyAddonOptionsPtrOutput) ResolveConflictsOnCreate() ResolveConflictsOnCreatePtrOutput {
	return o.ApplyT(func(v *KubeProxyAddonOptions) *ResolveConflictsOnCreate {
		if v == nil {
			return nil
		}
		return v.ResolveConflictsOnCreate
	}).(ResolveConflictsOnCreatePtrOutput)
}

// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
func (o KubeProxyAddonOptionsPtrOutput) ResolveConflictsOnUpdate() ResolveConflictsOnUpdatePtrOutput {
	return o.ApplyT(func(v *KubeProxyAddonOptions) *ResolveConflictsOnUpdate {
		if v == nil {
			return nil
		}
		return v.ResolveConflictsOnUpdate
	}).(ResolveConflictsOnUpdatePtrOutput)
}

// The version of the EKS add-on. The version must match one of the versions returned by [describe-addon-versions](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-versions.html).
func (o KubeProxyAddonOptionsPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeProxyAddonOptions) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptions struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName *string `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn *string `pulumi:"roleArn"`
}

// KubeconfigOptionsInput is an input type that accepts KubeconfigOptionsArgs and KubeconfigOptionsOutput values.
// You can construct a concrete instance of `KubeconfigOptionsInput` via:
//
//	KubeconfigOptionsArgs{...}
type KubeconfigOptionsInput interface {
	pulumi.Input

	ToKubeconfigOptionsOutput() KubeconfigOptionsOutput
	ToKubeconfigOptionsOutputWithContext(context.Context) KubeconfigOptionsOutput
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsArgs struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName pulumi.StringPtrInput `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn pulumi.StringPtrInput `pulumi:"roleArn"`
}

func (KubeconfigOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return i.ToKubeconfigOptionsOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput)
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput).ToKubeconfigOptionsPtrOutputWithContext(ctx)
}

// KubeconfigOptionsPtrInput is an input type that accepts KubeconfigOptionsArgs, KubeconfigOptionsPtr and KubeconfigOptionsPtrOutput values.
// You can construct a concrete instance of `KubeconfigOptionsPtrInput` via:
//
//	        KubeconfigOptionsArgs{...}
//
//	or:
//
//	        nil
type KubeconfigOptionsPtrInput interface {
	pulumi.Input

	ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput
	ToKubeconfigOptionsPtrOutputWithContext(context.Context) KubeconfigOptionsPtrOutput
}

type kubeconfigOptionsPtrType KubeconfigOptionsArgs

func KubeconfigOptionsPtr(v *KubeconfigOptionsArgs) KubeconfigOptionsPtrInput {
	return (*kubeconfigOptionsPtrType)(v)
}

func (*kubeconfigOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsPtrOutput)
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//  1. Assume a role on the default account caller,
//  2. Use an AWS creds profile instead of the default account caller,
//  3. Use an AWS creds creds profile instead of the default account caller,
//     and then assume a given role on the profile. This scenario is also
//     possible by only using a profile, iff the profile includes a role to
//     assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KubeconfigOptions) *KubeconfigOptions {
		return &v
	}).(KubeconfigOptionsPtrOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.ProfileName }).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.RoleArn }).(pulumi.StringPtrOutput)
}

type KubeconfigOptionsPtrOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) Elem() KubeconfigOptionsOutput {
	return o.ApplyT(func(v *KubeconfigOptions) KubeconfigOptions {
		if v != nil {
			return *v
		}
		var ret KubeconfigOptions
		return ret
	}).(KubeconfigOptionsOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsPtrOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.ProfileName
	}).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupData struct {
	// The AutoScalingGroup name for the node group.
	AutoScalingGroupName string `pulumi:"autoScalingGroupName"`
	// The CloudFormation Stack which defines the Node AutoScalingGroup.
	CfnStack *cloudformation.Stack `pulumi:"cfnStack"`
	// The additional security groups for the node group that captures user-specific rules.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// The security group for the node group to communicate with the cluster.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupDataOutput struct{ *pulumi.OutputState }

func (NodeGroupDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutput() NodeGroupDataOutput {
	return o
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutputWithContext(ctx context.Context) NodeGroupDataOutput {
	return o
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataOutput) AutoScalingGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v NodeGroupData) string { return v.AutoScalingGroupName }).(pulumi.StringOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v NodeGroupData) *cloudformation.Stack { return v.CfnStack }).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v NodeGroupData) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v NodeGroupData) *ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

type NodeGroupDataPtrOutput struct{ *pulumi.OutputState }

func (NodeGroupDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) Elem() NodeGroupDataOutput {
	return o.ApplyT(func(v *NodeGroupData) NodeGroupData {
		if v != nil {
			return *v
		}
		var ret NodeGroupData
		return ret
	}).(NodeGroupDataOutput)
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataPtrOutput) AutoScalingGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeGroupData) *string {
		if v == nil {
			return nil
		}
		return &v.AutoScalingGroupName
	}).(pulumi.StringPtrOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataPtrOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v *NodeGroupData) *cloudformation.Stack {
		if v == nil {
			return nil
		}
		return v.CfnStack
	}).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *NodeGroupData) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *NodeGroupData) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// MIME document parts for nodeadm configuration. This can be shell scripts, nodeadm configuration or any other user data compatible script.
//
// See for more details: https://awslabs.github.io/amazon-eks-ami/nodeadm/.
type NodeadmOptions struct {
	// The ARN of the access policy to associate with the principal
	Content string `pulumi:"content"`
	// The MIME type of the content. Examples are `text/x-shellscript; charset="us-ascii"` for shell scripts, and `application/node.eks.aws` nodeadm configuration.
	ContentType string `pulumi:"contentType"`
}

// NodeadmOptionsInput is an input type that accepts NodeadmOptionsArgs and NodeadmOptionsOutput values.
// You can construct a concrete instance of `NodeadmOptionsInput` via:
//
//	NodeadmOptionsArgs{...}
type NodeadmOptionsInput interface {
	pulumi.Input

	ToNodeadmOptionsOutput() NodeadmOptionsOutput
	ToNodeadmOptionsOutputWithContext(context.Context) NodeadmOptionsOutput
}

// MIME document parts for nodeadm configuration. This can be shell scripts, nodeadm configuration or any other user data compatible script.
//
// See for more details: https://awslabs.github.io/amazon-eks-ami/nodeadm/.
type NodeadmOptionsArgs struct {
	// The ARN of the access policy to associate with the principal
	Content pulumi.StringInput `pulumi:"content"`
	// The MIME type of the content. Examples are `text/x-shellscript; charset="us-ascii"` for shell scripts, and `application/node.eks.aws` nodeadm configuration.
	ContentType pulumi.StringInput `pulumi:"contentType"`
}

func (NodeadmOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeadmOptions)(nil)).Elem()
}

func (i NodeadmOptionsArgs) ToNodeadmOptionsOutput() NodeadmOptionsOutput {
	return i.ToNodeadmOptionsOutputWithContext(context.Background())
}

func (i NodeadmOptionsArgs) ToNodeadmOptionsOutputWithContext(ctx context.Context) NodeadmOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeadmOptionsOutput)
}

// NodeadmOptionsArrayInput is an input type that accepts NodeadmOptionsArray and NodeadmOptionsArrayOutput values.
// You can construct a concrete instance of `NodeadmOptionsArrayInput` via:
//
//	NodeadmOptionsArray{ NodeadmOptionsArgs{...} }
type NodeadmOptionsArrayInput interface {
	pulumi.Input

	ToNodeadmOptionsArrayOutput() NodeadmOptionsArrayOutput
	ToNodeadmOptionsArrayOutputWithContext(context.Context) NodeadmOptionsArrayOutput
}

type NodeadmOptionsArray []NodeadmOptionsInput

func (NodeadmOptionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeadmOptions)(nil)).Elem()
}

func (i NodeadmOptionsArray) ToNodeadmOptionsArrayOutput() NodeadmOptionsArrayOutput {
	return i.ToNodeadmOptionsArrayOutputWithContext(context.Background())
}

func (i NodeadmOptionsArray) ToNodeadmOptionsArrayOutputWithContext(ctx context.Context) NodeadmOptionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeadmOptionsArrayOutput)
}

// MIME document parts for nodeadm configuration. This can be shell scripts, nodeadm configuration or any other user data compatible script.
//
// See for more details: https://awslabs.github.io/amazon-eks-ami/nodeadm/.
type NodeadmOptionsOutput struct{ *pulumi.OutputState }

func (NodeadmOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeadmOptions)(nil)).Elem()
}

func (o NodeadmOptionsOutput) ToNodeadmOptionsOutput() NodeadmOptionsOutput {
	return o
}

func (o NodeadmOptionsOutput) ToNodeadmOptionsOutputWithContext(ctx context.Context) NodeadmOptionsOutput {
	return o
}

// The ARN of the access policy to associate with the principal
func (o NodeadmOptionsOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v NodeadmOptions) string { return v.Content }).(pulumi.StringOutput)
}

// The MIME type of the content. Examples are `text/x-shellscript; charset="us-ascii"` for shell scripts, and `application/node.eks.aws` nodeadm configuration.
func (o NodeadmOptionsOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v NodeadmOptions) string { return v.ContentType }).(pulumi.StringOutput)
}

type NodeadmOptionsArrayOutput struct{ *pulumi.OutputState }

func (NodeadmOptionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeadmOptions)(nil)).Elem()
}

func (o NodeadmOptionsArrayOutput) ToNodeadmOptionsArrayOutput() NodeadmOptionsArrayOutput {
	return o
}

func (o NodeadmOptionsArrayOutput) ToNodeadmOptionsArrayOutputWithContext(ctx context.Context) NodeadmOptionsArrayOutput {
	return o
}

func (o NodeadmOptionsArrayOutput) Index(i pulumi.IntInput) NodeadmOptionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NodeadmOptions {
		return vs[0].([]NodeadmOptions)[vs[1].(int)]
	}).(NodeadmOptionsOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMapping struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn string `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username string `pulumi:"username"`
}

// RoleMappingInput is an input type that accepts RoleMappingArgs and RoleMappingOutput values.
// You can construct a concrete instance of `RoleMappingInput` via:
//
//	RoleMappingArgs{...}
type RoleMappingInput interface {
	pulumi.Input

	ToRoleMappingOutput() RoleMappingOutput
	ToRoleMappingOutputWithContext(context.Context) RoleMappingOutput
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingArgs struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username pulumi.StringInput `pulumi:"username"`
}

func (RoleMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (i RoleMappingArgs) ToRoleMappingOutput() RoleMappingOutput {
	return i.ToRoleMappingOutputWithContext(context.Background())
}

func (i RoleMappingArgs) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingOutput)
}

// RoleMappingArrayInput is an input type that accepts RoleMappingArray and RoleMappingArrayOutput values.
// You can construct a concrete instance of `RoleMappingArrayInput` via:
//
//	RoleMappingArray{ RoleMappingArgs{...} }
type RoleMappingArrayInput interface {
	pulumi.Input

	ToRoleMappingArrayOutput() RoleMappingArrayOutput
	ToRoleMappingArrayOutputWithContext(context.Context) RoleMappingArrayOutput
}

type RoleMappingArray []RoleMappingInput

func (RoleMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (i RoleMappingArray) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return i.ToRoleMappingArrayOutputWithContext(context.Background())
}

func (i RoleMappingArray) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingArrayOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingOutput struct{ *pulumi.OutputState }

func (RoleMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (o RoleMappingOutput) ToRoleMappingOutput() RoleMappingOutput {
	return o
}

func (o RoleMappingOutput) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the role is mapped.
func (o RoleMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RoleMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM role to add.
func (o RoleMappingOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.RoleArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
func (o RoleMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.Username }).(pulumi.StringOutput)
}

type RoleMappingArrayOutput struct{ *pulumi.OutputState }

func (RoleMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) Index(i pulumi.IntInput) RoleMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RoleMapping {
		return vs[0].([]RoleMapping)[vs[1].(int)]
	}).(RoleMappingOutput)
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClass struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand.
	AllowVolumeExpansion *bool `pulumi:"allowVolumeExpansion"`
	// True if this storage class should be a default storage class for the cluster.
	//
	// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
	//
	// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
	Default *bool `pulumi:"default"`
	// Denotes whether the EBS volume should be encrypted.
	Encrypted *bool `pulumi:"encrypted"`
	// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
	IopsPerGb *int `pulumi:"iopsPerGb"`
	// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions []string `pulumi:"mountOptions"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy *string `pulumi:"reclaimPolicy"`
	// The EBS volume type.
	Type string `pulumi:"type"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode *string `pulumi:"volumeBindingMode"`
	// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
	Zones []string `pulumi:"zones"`
}

// StorageClassInput is an input type that accepts StorageClassArgs and StorageClassOutput values.
// You can construct a concrete instance of `StorageClassInput` via:
//
//	StorageClassArgs{...}
type StorageClassInput interface {
	pulumi.Input

	ToStorageClassOutput() StorageClassOutput
	ToStorageClassOutputWithContext(context.Context) StorageClassOutput
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClassArgs struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand.
	AllowVolumeExpansion pulumi.BoolPtrInput `pulumi:"allowVolumeExpansion"`
	// True if this storage class should be a default storage class for the cluster.
	//
	// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
	//
	// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
	Default pulumi.BoolPtrInput `pulumi:"default"`
	// Denotes whether the EBS volume should be encrypted.
	Encrypted pulumi.BoolPtrInput `pulumi:"encrypted"`
	// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
	IopsPerGb pulumi.IntPtrInput `pulumi:"iopsPerGb"`
	// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
	KmsKeyId pulumi.StringPtrInput `pulumi:"kmsKeyId"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions pulumi.StringArrayInput `pulumi:"mountOptions"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy pulumi.StringPtrInput `pulumi:"reclaimPolicy"`
	// The EBS volume type.
	Type pulumi.StringInput `pulumi:"type"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode pulumi.StringPtrInput `pulumi:"volumeBindingMode"`
	// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
	Zones pulumi.StringArrayInput `pulumi:"zones"`
}

func (StorageClassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageClass)(nil)).Elem()
}

func (i StorageClassArgs) ToStorageClassOutput() StorageClassOutput {
	return i.ToStorageClassOutputWithContext(context.Background())
}

func (i StorageClassArgs) ToStorageClassOutputWithContext(ctx context.Context) StorageClassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageClassOutput)
}

// StorageClassMapInput is an input type that accepts StorageClassMap and StorageClassMapOutput values.
// You can construct a concrete instance of `StorageClassMapInput` via:
//
//	StorageClassMap{ "key": StorageClassArgs{...} }
type StorageClassMapInput interface {
	pulumi.Input

	ToStorageClassMapOutput() StorageClassMapOutput
	ToStorageClassMapOutputWithContext(context.Context) StorageClassMapOutput
}

type StorageClassMap map[string]StorageClassInput

func (StorageClassMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]StorageClass)(nil)).Elem()
}

func (i StorageClassMap) ToStorageClassMapOutput() StorageClassMapOutput {
	return i.ToStorageClassMapOutputWithContext(context.Background())
}

func (i StorageClassMap) ToStorageClassMapOutputWithContext(ctx context.Context) StorageClassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageClassMapOutput)
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClassOutput struct{ *pulumi.OutputState }

func (StorageClassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageClass)(nil)).Elem()
}

func (o StorageClassOutput) ToStorageClassOutput() StorageClassOutput {
	return o
}

func (o StorageClassOutput) ToStorageClassOutputWithContext(ctx context.Context) StorageClassOutput {
	return o
}

// AllowVolumeExpansion shows whether the storage class allow volume expand.
func (o StorageClassOutput) AllowVolumeExpansion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.AllowVolumeExpansion }).(pulumi.BoolPtrOutput)
}

// True if this storage class should be a default storage class for the cluster.
//
// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
//
// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
func (o StorageClassOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.Default }).(pulumi.BoolPtrOutput)
}

// Denotes whether the EBS volume should be encrypted.
func (o StorageClassOutput) Encrypted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.Encrypted }).(pulumi.BoolPtrOutput)
}

// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
func (o StorageClassOutput) IopsPerGb() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StorageClass) *int { return v.IopsPerGb }).(pulumi.IntPtrOutput)
}

// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
func (o StorageClassOutput) KmsKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.KmsKeyId }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
func (o StorageClassOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v StorageClass) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
func (o StorageClassOutput) MountOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StorageClass) []string { return v.MountOptions }).(pulumi.StringArrayOutput)
}

// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
func (o StorageClassOutput) ReclaimPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.ReclaimPolicy }).(pulumi.StringPtrOutput)
}

// The EBS volume type.
func (o StorageClassOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageClass) string { return v.Type }).(pulumi.StringOutput)
}

// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
func (o StorageClassOutput) VolumeBindingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.VolumeBindingMode }).(pulumi.StringPtrOutput)
}

// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
func (o StorageClassOutput) Zones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StorageClass) []string { return v.Zones }).(pulumi.StringArrayOutput)
}

type StorageClassMapOutput struct{ *pulumi.OutputState }

func (StorageClassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]StorageClass)(nil)).Elem()
}

func (o StorageClassMapOutput) ToStorageClassMapOutput() StorageClassMapOutput {
	return o
}

func (o StorageClassMapOutput) ToStorageClassMapOutputWithContext(ctx context.Context) StorageClassMapOutput {
	return o
}

func (o StorageClassMapOutput) MapIndex(k pulumi.StringInput) StorageClassOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) StorageClass {
		return vs[0].(map[string]StorageClass)[vs[1].(string)]
	}).(StorageClassOutput)
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type Taint struct {
	// The effect of the taint.
	Effect string `pulumi:"effect"`
	// The value of the taint.
	Value string `pulumi:"value"`
}

// TaintInput is an input type that accepts TaintArgs and TaintOutput values.
// You can construct a concrete instance of `TaintInput` via:
//
//	TaintArgs{...}
type TaintInput interface {
	pulumi.Input

	ToTaintOutput() TaintOutput
	ToTaintOutputWithContext(context.Context) TaintOutput
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintArgs struct {
	// The effect of the taint.
	Effect string `pulumi:"effect"`
	// The value of the taint.
	Value string `pulumi:"value"`
}

func (TaintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (i TaintArgs) ToTaintOutput() TaintOutput {
	return i.ToTaintOutputWithContext(context.Background())
}

func (i TaintArgs) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintOutput)
}

// TaintMapInput is an input type that accepts TaintMap and TaintMapOutput values.
// You can construct a concrete instance of `TaintMapInput` via:
//
//	TaintMap{ "key": TaintArgs{...} }
type TaintMapInput interface {
	pulumi.Input

	ToTaintMapOutput() TaintMapOutput
	ToTaintMapOutputWithContext(context.Context) TaintMapOutput
}

type TaintMap map[string]TaintInput

func (TaintMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (i TaintMap) ToTaintMapOutput() TaintMapOutput {
	return i.ToTaintMapOutputWithContext(context.Background())
}

func (i TaintMap) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintMapOutput)
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintOutput struct{ *pulumi.OutputState }

func (TaintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (o TaintOutput) ToTaintOutput() TaintOutput {
	return o
}

func (o TaintOutput) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return o
}

// The effect of the taint.
func (o TaintOutput) Effect() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Effect }).(pulumi.StringOutput)
}

// The value of the taint.
func (o TaintOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Value }).(pulumi.StringOutput)
}

type TaintMapOutput struct{ *pulumi.OutputState }

func (TaintMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (o TaintMapOutput) ToTaintMapOutput() TaintMapOutput {
	return o
}

func (o TaintMapOutput) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return o
}

func (o TaintMapOutput) MapIndex(k pulumi.StringInput) TaintOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Taint {
		return vs[0].(map[string]Taint)[vs[1].(string)]
	}).(TaintOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMapping struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn string `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username string `pulumi:"username"`
}

// UserMappingInput is an input type that accepts UserMappingArgs and UserMappingOutput values.
// You can construct a concrete instance of `UserMappingInput` via:
//
//	UserMappingArgs{...}
type UserMappingInput interface {
	pulumi.Input

	ToUserMappingOutput() UserMappingOutput
	ToUserMappingOutputWithContext(context.Context) UserMappingOutput
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingArgs struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn pulumi.StringInput `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username pulumi.StringInput `pulumi:"username"`
}

func (UserMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (i UserMappingArgs) ToUserMappingOutput() UserMappingOutput {
	return i.ToUserMappingOutputWithContext(context.Background())
}

func (i UserMappingArgs) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingOutput)
}

// UserMappingArrayInput is an input type that accepts UserMappingArray and UserMappingArrayOutput values.
// You can construct a concrete instance of `UserMappingArrayInput` via:
//
//	UserMappingArray{ UserMappingArgs{...} }
type UserMappingArrayInput interface {
	pulumi.Input

	ToUserMappingArrayOutput() UserMappingArrayOutput
	ToUserMappingArrayOutputWithContext(context.Context) UserMappingArrayOutput
}

type UserMappingArray []UserMappingInput

func (UserMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (i UserMappingArray) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return i.ToUserMappingArrayOutputWithContext(context.Background())
}

func (i UserMappingArray) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingArrayOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingOutput struct{ *pulumi.OutputState }

func (UserMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (o UserMappingOutput) ToUserMappingOutput() UserMappingOutput {
	return o
}

func (o UserMappingOutput) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the user is mapped to.
func (o UserMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM user to add.
func (o UserMappingOutput) UserArn() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.UserArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
func (o UserMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.Username }).(pulumi.StringOutput)
}

type UserMappingArrayOutput struct{ *pulumi.OutputState }

func (UserMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) Index(i pulumi.IntInput) UserMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserMapping {
		return vs[0].([]UserMapping)[vs[1].(int)]
	}).(UserMappingOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptions struct {
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter *bool `pulumi:"cniConfigureRpfilter"`
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg *bool `pulumi:"cniCustomNetworkCfg"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat *bool `pulumi:"cniExternalSnat"`
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig *bool `pulumi:"customNetworkConfig"`
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux *bool `pulumi:"disableTcpEarlyDemux"`
	// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni *bool `pulumi:"enablePodEni"`
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation *bool `pulumi:"enablePrefixDelegation"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef *string `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu *int `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat *bool `pulumi:"externalSnat"`
	// Specifies the aws-node container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image *string `pulumi:"image"`
	// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI init container image in ECR.
	InitImage *string `pulumi:"initImage"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile *string `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel *string `pulumi:"logLevel"`
	// Specifies the aws-eks-nodeagent container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI nodeagent image in ECR.
	NodeAgentImage *string `pulumi:"nodeAgentImage"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport *bool `pulumi:"nodePortSupport"`
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged *bool `pulumi:"securityContextPrivileged"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix *string `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget *int `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget *int `pulumi:"warmIpTarget"`
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget *int `pulumi:"warmPrefixTarget"`
}

// VpcCniOptionsInput is an input type that accepts VpcCniOptionsArgs and VpcCniOptionsOutput values.
// You can construct a concrete instance of `VpcCniOptionsInput` via:
//
//	VpcCniOptionsArgs{...}
type VpcCniOptionsInput interface {
	pulumi.Input

	ToVpcCniOptionsOutput() VpcCniOptionsOutput
	ToVpcCniOptionsOutputWithContext(context.Context) VpcCniOptionsOutput
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsArgs struct {
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter pulumi.BoolPtrInput `pulumi:"cniConfigureRpfilter"`
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg pulumi.BoolPtrInput `pulumi:"cniCustomNetworkCfg"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat pulumi.BoolPtrInput `pulumi:"cniExternalSnat"`
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig pulumi.BoolPtrInput `pulumi:"customNetworkConfig"`
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux pulumi.BoolPtrInput `pulumi:"disableTcpEarlyDemux"`
	// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
	EnableIpv6 pulumi.BoolPtrInput `pulumi:"enableIpv6"`
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni pulumi.BoolPtrInput `pulumi:"enablePodEni"`
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation pulumi.BoolPtrInput `pulumi:"enablePrefixDelegation"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef pulumi.StringPtrInput `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu pulumi.IntPtrInput `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat pulumi.BoolPtrInput `pulumi:"externalSnat"`
	// Specifies the aws-node container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI init container image in ECR.
	InitImage pulumi.StringPtrInput `pulumi:"initImage"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile pulumi.StringPtrInput `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel pulumi.StringPtrInput `pulumi:"logLevel"`
	// Specifies the aws-eks-nodeagent container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI nodeagent image in ECR.
	NodeAgentImage pulumi.StringPtrInput `pulumi:"nodeAgentImage"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport pulumi.BoolPtrInput `pulumi:"nodePortSupport"`
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged pulumi.BoolPtrInput `pulumi:"securityContextPrivileged"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix pulumi.StringPtrInput `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget pulumi.IntPtrInput `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget pulumi.IntPtrInput `pulumi:"warmIpTarget"`
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget pulumi.IntPtrInput `pulumi:"warmPrefixTarget"`
}

func (VpcCniOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return i.ToVpcCniOptionsOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput)
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput).ToVpcCniOptionsPtrOutputWithContext(ctx)
}

// VpcCniOptionsPtrInput is an input type that accepts VpcCniOptionsArgs, VpcCniOptionsPtr and VpcCniOptionsPtrOutput values.
// You can construct a concrete instance of `VpcCniOptionsPtrInput` via:
//
//	        VpcCniOptionsArgs{...}
//
//	or:
//
//	        nil
type VpcCniOptionsPtrInput interface {
	pulumi.Input

	ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput
	ToVpcCniOptionsPtrOutputWithContext(context.Context) VpcCniOptionsPtrOutput
}

type vpcCniOptionsPtrType VpcCniOptionsArgs

func VpcCniOptionsPtr(v *VpcCniOptionsArgs) VpcCniOptionsPtrInput {
	return (*vpcCniOptionsPtrType)(v)
}

func (*vpcCniOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsPtrOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VpcCniOptions) *VpcCniOptions {
		return &v
	}).(VpcCniOptionsPtrOutput)
}

// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
func (o VpcCniOptionsOutput) CniConfigureRpfilter() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniConfigureRpfilter }).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
func (o VpcCniOptionsOutput) CniCustomNetworkCfg() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniCustomNetworkCfg }).(pulumi.BoolPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
func (o VpcCniOptionsOutput) CniExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CniExternalSnat }).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CustomNetworkConfig }).(pulumi.BoolPtrOutput)
}

// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
func (o VpcCniOptionsOutput) DisableTcpEarlyDemux() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.DisableTcpEarlyDemux }).(pulumi.BoolPtrOutput)
}

// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
func (o VpcCniOptionsOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
func (o VpcCniOptionsOutput) EnablePodEni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnablePodEni }).(pulumi.BoolPtrOutput)
}

// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
func (o VpcCniOptionsOutput) EnablePrefixDelegation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.EnablePrefixDelegation }).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.EniConfigLabelDef }).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.EniMtu }).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.ExternalSnat }).(pulumi.BoolPtrOutput)
}

// Specifies the aws-node container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI init container image in ECR.
func (o VpcCniOptionsOutput) InitImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.InitImage }).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogFile }).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogLevel }).(pulumi.StringPtrOutput)
}

// Specifies the aws-eks-nodeagent container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI nodeagent image in ECR.
func (o VpcCniOptionsOutput) NodeAgentImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.NodeAgentImage }).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.NodePortSupport }).(pulumi.BoolPtrOutput)
}

// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
func (o VpcCniOptionsOutput) SecurityContextPrivileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.SecurityContextPrivileged }).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.VethPrefix }).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmEniTarget }).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmIpTarget }).(pulumi.IntPtrOutput)
}

// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
func (o VpcCniOptionsOutput) WarmPrefixTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmPrefixTarget }).(pulumi.IntPtrOutput)
}

type VpcCniOptionsPtrOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) Elem() VpcCniOptionsOutput {
	return o.ApplyT(func(v *VpcCniOptions) VpcCniOptions {
		if v != nil {
			return *v
		}
		var ret VpcCniOptions
		return ret
	}).(VpcCniOptionsOutput)
}

// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
func (o VpcCniOptionsPtrOutput) CniConfigureRpfilter() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniConfigureRpfilter
	}).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
func (o VpcCniOptionsPtrOutput) CniCustomNetworkCfg() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniCustomNetworkCfg
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
func (o VpcCniOptionsPtrOutput) CniExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CniExternalSnat
	}).(pulumi.BoolPtrOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CustomNetworkConfig
	}).(pulumi.BoolPtrOutput)
}

// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
func (o VpcCniOptionsPtrOutput) DisableTcpEarlyDemux() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableTcpEarlyDemux
	}).(pulumi.BoolPtrOutput)
}

// VPC CNI can operate in either IPv4 or IPv6 mode. Setting ENABLE_IPv6 to true. will configure it in IPv6 mode. IPv6 is only supported in Prefix Delegation mode, so ENABLE_PREFIX_DELEGATION needs to set to true if VPC CNI is configured to operate in IPv6 mode. Prefix delegation is only supported on nitro instances.
func (o VpcCniOptionsPtrOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnableIpv6
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
func (o VpcCniOptionsPtrOutput) EnablePodEni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnablePodEni
	}).(pulumi.BoolPtrOutput)
}

// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
func (o VpcCniOptionsPtrOutput) EnablePrefixDelegation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EnablePrefixDelegation
	}).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.EniConfigLabelDef
	}).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsPtrOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.EniMtu
	}).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.ExternalSnat
	}).(pulumi.BoolPtrOutput)
}

// Specifies the aws-node container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Specifies the init container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI init container image in ECR.
func (o VpcCniOptionsPtrOutput) InitImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.InitImage
	}).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsPtrOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogFile
	}).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsPtrOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogLevel
	}).(pulumi.StringPtrOutput)
}

// Specifies the aws-eks-nodeagent container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI nodeagent image in ECR.
func (o VpcCniOptionsPtrOutput) NodeAgentImage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeAgentImage
	}).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsPtrOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodePortSupport
	}).(pulumi.BoolPtrOutput)
}

// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
func (o VpcCniOptionsPtrOutput) SecurityContextPrivileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.SecurityContextPrivileged
	}).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsPtrOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.VethPrefix
	}).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsPtrOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmEniTarget
	}).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsPtrOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmIpTarget
	}).(pulumi.IntPtrOutput)
}

// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
func (o VpcCniOptionsPtrOutput) WarmPrefixTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmPrefixTarget
	}).(pulumi.IntPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessEntryInput)(nil)).Elem(), AccessEntryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessEntryArrayInput)(nil)).Elem(), AccessEntryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessPolicyAssociationInput)(nil)).Elem(), AccessPolicyAssociationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessPolicyAssociationMapInput)(nil)).Elem(), AccessPolicyAssociationMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterNodeGroupOptionsInput)(nil)).Elem(), ClusterNodeGroupOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterNodeGroupOptionsPtrInput)(nil)).Elem(), ClusterNodeGroupOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CoreDataInput)(nil)).Elem(), CoreDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CoreDnsAddonOptionsInput)(nil)).Elem(), CoreDnsAddonOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CoreDnsAddonOptionsPtrInput)(nil)).Elem(), CoreDnsAddonOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CreationRoleProviderInput)(nil)).Elem(), CreationRoleProviderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CreationRoleProviderPtrInput)(nil)).Elem(), CreationRoleProviderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FargateProfileInput)(nil)).Elem(), FargateProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FargateProfilePtrInput)(nil)).Elem(), FargateProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeProxyAddonOptionsInput)(nil)).Elem(), KubeProxyAddonOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeProxyAddonOptionsPtrInput)(nil)).Elem(), KubeProxyAddonOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeconfigOptionsInput)(nil)).Elem(), KubeconfigOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubeconfigOptionsPtrInput)(nil)).Elem(), KubeconfigOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodeadmOptionsInput)(nil)).Elem(), NodeadmOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodeadmOptionsArrayInput)(nil)).Elem(), NodeadmOptionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleMappingInput)(nil)).Elem(), RoleMappingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RoleMappingArrayInput)(nil)).Elem(), RoleMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageClassInput)(nil)).Elem(), StorageClassArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageClassMapInput)(nil)).Elem(), StorageClassMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaintInput)(nil)).Elem(), TaintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaintMapInput)(nil)).Elem(), TaintMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMappingInput)(nil)).Elem(), UserMappingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMappingArrayInput)(nil)).Elem(), UserMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniOptionsInput)(nil)).Elem(), VpcCniOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniOptionsPtrInput)(nil)).Elem(), VpcCniOptionsArgs{})
	pulumi.RegisterOutputType(AccessEntryOutput{})
	pulumi.RegisterOutputType(AccessEntryArrayOutput{})
	pulumi.RegisterOutputType(AccessPolicyAssociationOutput{})
	pulumi.RegisterOutputType(AccessPolicyAssociationMapOutput{})
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsOutput{})
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsPtrOutput{})
	pulumi.RegisterOutputType(CoreDataOutput{})
	pulumi.RegisterOutputType(CoreDnsAddonOptionsOutput{})
	pulumi.RegisterOutputType(CoreDnsAddonOptionsPtrOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderPtrOutput{})
	pulumi.RegisterOutputType(FargateProfileOutput{})
	pulumi.RegisterOutputType(FargateProfilePtrOutput{})
	pulumi.RegisterOutputType(KubeProxyAddonOptionsOutput{})
	pulumi.RegisterOutputType(KubeProxyAddonOptionsPtrOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsPtrOutput{})
	pulumi.RegisterOutputType(NodeGroupDataOutput{})
	pulumi.RegisterOutputType(NodeGroupDataPtrOutput{})
	pulumi.RegisterOutputType(NodeadmOptionsOutput{})
	pulumi.RegisterOutputType(NodeadmOptionsArrayOutput{})
	pulumi.RegisterOutputType(RoleMappingOutput{})
	pulumi.RegisterOutputType(RoleMappingArrayOutput{})
	pulumi.RegisterOutputType(StorageClassOutput{})
	pulumi.RegisterOutputType(StorageClassMapOutput{})
	pulumi.RegisterOutputType(TaintOutput{})
	pulumi.RegisterOutputType(TaintMapOutput{})
	pulumi.RegisterOutputType(UserMappingOutput{})
	pulumi.RegisterOutputType(UserMappingArrayOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsPtrOutput{})
}
