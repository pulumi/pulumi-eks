// *** WARNING: this file was generated by pulumi-gen-eks. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v3/go/aws"
	"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/cloudformation"
	"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/ec2"
	"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/eks"
	"github.com/pulumi/pulumi-aws/sdk/v3/go/aws/iam"
	"github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	storagev1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/storage/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptions struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId *string `pulumi:"amiId"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags map[string]string `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. Fror details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs *string `pulumi:"bootstrapExtraArgs"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags map[string]string `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule *ec2.SecurityGroupRule `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity *int `pulumi:"desiredCapacity"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice *bool `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu *bool `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile *iam.InstanceProfile `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType *string `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName *string `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the expicit `kubeletExtraArgs`.
	KubeletExtraArgs *string `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each woker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize *int `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize *int `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress *bool `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey *string `pulumi:"nodePublicKey"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize *int `pulumi:"nodeRootVolumeSize"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup *ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds []string `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData *string `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride *string `pulumi:"nodeUserDataOverride"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice *string `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints map[string]Taint `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version *string `pulumi:"version"`
}

// ClusterNodeGroupOptionsInput is an input type that accepts ClusterNodeGroupOptionsArgs and ClusterNodeGroupOptionsOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsInput` via:
//
//          ClusterNodeGroupOptionsArgs{...}
type ClusterNodeGroupOptionsInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput
	ToClusterNodeGroupOptionsOutputWithContext(context.Context) ClusterNodeGroupOptionsOutput
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsArgs struct {
	// The AMI ID to use for the worker nodes.
	//
	// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
	//
	// Note: `amiId` and `gpu` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
	AmiId pulumi.StringPtrInput `pulumi:"amiId"`
	// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
	//
	// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	AutoScalingGroupTags pulumi.StringMapInput `pulumi:"autoScalingGroupTags"`
	// Additional args to pass directly to `/etc/eks/bootstrap.sh`. Fror details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
	BootstrapExtraArgs pulumi.StringPtrInput `pulumi:"bootstrapExtraArgs"`
	// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
	//
	// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
	CloudFormationTags pulumi.StringMapInput `pulumi:"cloudFormationTags"`
	// The ingress rule that gives node group access.
	ClusterIngressRule ec2.SecurityGroupRuleInput `pulumi:"clusterIngressRule"`
	// The number of worker nodes that should be running in the cluster. Defaults to 2.
	DesiredCapacity pulumi.IntPtrInput `pulumi:"desiredCapacity"`
	// Encrypt the root block device of the nodes in the node group.
	EncryptRootBlockDevice pulumi.BoolPtrInput `pulumi:"encryptRootBlockDevice"`
	// Extra security groups to attach on all nodes in this worker node group.
	//
	// This additional set of security groups captures any user application rules that will be needed for the nodes.
	ExtraNodeSecurityGroups ec2.SecurityGroupArrayInput `pulumi:"extraNodeSecurityGroups"`
	// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
	//
	// Defaults to false.
	//
	// Note: `gpu` and `amiId` are mutually exclusive.
	//
	// See for more details:
	// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
	// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
	Gpu pulumi.BoolPtrInput `pulumi:"gpu"`
	// The ingress rule that gives node group access.
	InstanceProfile iam.InstanceProfileInput `pulumi:"instanceProfile"`
	// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
	InstanceType pulumi.StringPtrInput `pulumi:"instanceType"`
	// Name of the key pair to use for SSH access to worker nodes.
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
	// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the expicit `kubeletExtraArgs`.
	KubeletExtraArgs pulumi.StringPtrInput `pulumi:"kubeletExtraArgs"`
	// Custom k8s node labels to be attached to each woker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The maximum number of worker nodes running in the cluster. Defaults to 2.
	MaxSize pulumi.IntPtrInput `pulumi:"maxSize"`
	// The minimum number of worker nodes running in the cluster. Defaults to 1.
	MinSize pulumi.IntPtrInput `pulumi:"minSize"`
	// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
	NodeAssociatePublicIpAddress pulumi.BoolPtrInput `pulumi:"nodeAssociatePublicIpAddress"`
	// Public key material for SSH access to worker nodes. See allowed formats at:
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
	// If not provided, no SSH access is enabled on VMs.
	NodePublicKey pulumi.StringPtrInput `pulumi:"nodePublicKey"`
	// The size in GiB of a cluster node's root volume. Defaults to 20.
	NodeRootVolumeSize pulumi.IntPtrInput `pulumi:"nodeRootVolumeSize"`
	// The security group for the worker node group to communicate with the cluster.
	//
	// This security group requires specific inbound and outbound rules.
	//
	// See for more details:
	// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
	//
	// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
	NodeSecurityGroup ec2.SecurityGroupInput `pulumi:"nodeSecurityGroup"`
	// The set of subnets to override and use for the worker node group.
	//
	// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
	NodeSubnetIds pulumi.StringArrayInput `pulumi:"nodeSubnetIds"`
	// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
	NodeUserData pulumi.StringPtrInput `pulumi:"nodeUserData"`
	// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
	//
	// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
	NodeUserDataOverride pulumi.StringPtrInput `pulumi:"nodeUserDataOverride"`
	// Bidding price for spot instance. If set, only spot instances will be added as worker node.
	SpotPrice pulumi.StringPtrInput `pulumi:"spotPrice"`
	// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
	Taints TaintMapInput `pulumi:"taints"`
	// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ClusterNodeGroupOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return i.ToClusterNodeGroupOptionsOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput)
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i ClusterNodeGroupOptionsArgs) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsOutput).ToClusterNodeGroupOptionsPtrOutputWithContext(ctx)
}

// ClusterNodeGroupOptionsPtrInput is an input type that accepts ClusterNodeGroupOptionsArgs, ClusterNodeGroupOptionsPtr and ClusterNodeGroupOptionsPtrOutput values.
// You can construct a concrete instance of `ClusterNodeGroupOptionsPtrInput` via:
//
//          ClusterNodeGroupOptionsArgs{...}
//
//  or:
//
//          nil
type ClusterNodeGroupOptionsPtrInput interface {
	pulumi.Input

	ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput
	ToClusterNodeGroupOptionsPtrOutputWithContext(context.Context) ClusterNodeGroupOptionsPtrOutput
}

type clusterNodeGroupOptionsPtrType ClusterNodeGroupOptionsArgs

func ClusterNodeGroupOptionsPtr(v *ClusterNodeGroupOptionsArgs) ClusterNodeGroupOptionsPtrInput {
	return (*clusterNodeGroupOptionsPtrType)(v)
}

func (*clusterNodeGroupOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return i.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (i *clusterNodeGroupOptionsPtrType) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterNodeGroupOptionsPtrOutput)
}

// Describes the configuration options accepted by a cluster to create its own node groups.
type ClusterNodeGroupOptionsOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutput() ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsOutput {
	return o
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o.ToClusterNodeGroupOptionsPtrOutputWithContext(context.Background())
}

func (o ClusterNodeGroupOptionsOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ClusterNodeGroupOptions {
		return &v
	}).(ClusterNodeGroupOptionsPtrOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.AmiId }).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.AutoScalingGroupTags }).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. Fror details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.BootstrapExtraArgs }).(pulumi.StringPtrOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.CloudFormationTags }).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroupRule { return v.ClusterIngressRule }).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.DesiredCapacity }).(pulumi.IntPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.EncryptRootBlockDevice }).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.Gpu }).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *iam.InstanceProfile { return v.InstanceProfile }).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.InstanceType }).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the expicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.KubeletExtraArgs }).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each woker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MaxSize }).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.MinSize }).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *bool { return v.NodeAssociatePublicIpAddress }).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodePublicKey }).(pulumi.StringPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *int { return v.NodeRootVolumeSize }).(pulumi.IntPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) []string { return v.NodeSubnetIds }).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserData }).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.NodeUserDataOverride }).(pulumi.StringPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.SpotPrice }).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) map[string]Taint { return v.Taints }).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterNodeGroupOptions) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ClusterNodeGroupOptionsPtrOutput struct{ *pulumi.OutputState }

func (ClusterNodeGroupOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterNodeGroupOptions)(nil)).Elem()
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutput() ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) ToClusterNodeGroupOptionsPtrOutputWithContext(ctx context.Context) ClusterNodeGroupOptionsPtrOutput {
	return o
}

func (o ClusterNodeGroupOptionsPtrOutput) Elem() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) ClusterNodeGroupOptions { return *v }).(ClusterNodeGroupOptionsOutput)
}

// The AMI ID to use for the worker nodes.
//
// Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
//
// Note: `amiId` and `gpu` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
func (o ClusterNodeGroupOptionsPtrOutput) AmiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.AmiId
	}).(pulumi.StringPtrOutput)
}

// The tags to apply to the NodeGroup's AutoScalingGroup in the CloudFormation Stack.
//
// Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) AutoScalingGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.AutoScalingGroupTags
	}).(pulumi.StringMapOutput)
}

// Additional args to pass directly to `/etc/eks/bootstrap.sh`. Fror details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
func (o ClusterNodeGroupOptionsPtrOutput) BootstrapExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.BootstrapExtraArgs
	}).(pulumi.StringPtrOutput)
}

// The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
//
// Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
func (o ClusterNodeGroupOptionsPtrOutput) CloudFormationTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.CloudFormationTags
	}).(pulumi.StringMapOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) ClusterIngressRule() ec2.SecurityGroupRuleOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroupRule {
		if v == nil {
			return nil
		}
		return v.ClusterIngressRule
	}).(ec2.SecurityGroupRuleOutput)
}

// The number of worker nodes that should be running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) DesiredCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.DesiredCapacity
	}).(pulumi.IntPtrOutput)
}

// Encrypt the root block device of the nodes in the node group.
func (o ClusterNodeGroupOptionsPtrOutput) EncryptRootBlockDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.EncryptRootBlockDevice
	}).(pulumi.BoolPtrOutput)
}

// Extra security groups to attach on all nodes in this worker node group.
//
// This additional set of security groups captures any user application rules that will be needed for the nodes.
func (o ClusterNodeGroupOptionsPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
//
// Defaults to false.
//
// Note: `gpu` and `amiId` are mutually exclusive.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
// - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
func (o ClusterNodeGroupOptionsPtrOutput) Gpu() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.Gpu
	}).(pulumi.BoolPtrOutput)
}

// The ingress rule that gives node group access.
func (o ClusterNodeGroupOptionsPtrOutput) InstanceProfile() iam.InstanceProfileOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *iam.InstanceProfile {
		if v == nil {
			return nil
		}
		return v.InstanceProfile
	}).(iam.InstanceProfileOutput)
}

// The instance type to use for the cluster's nodes. Defaults to "t2.medium".
func (o ClusterNodeGroupOptionsPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Name of the key pair to use for SSH access to worker nodes.
func (o ClusterNodeGroupOptionsPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

// Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, '--port=10251 --address=0.0.0.0'. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the expicit `kubeletExtraArgs`.
func (o ClusterNodeGroupOptionsPtrOutput) KubeletExtraArgs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.KubeletExtraArgs
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node labels to be attached to each woker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
func (o ClusterNodeGroupOptionsPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The maximum number of worker nodes running in the cluster. Defaults to 2.
func (o ClusterNodeGroupOptionsPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum number of worker nodes running in the cluster. Defaults to 1.
func (o ClusterNodeGroupOptionsPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.MinSize
	}).(pulumi.IntPtrOutput)
}

// Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
func (o ClusterNodeGroupOptionsPtrOutput) NodeAssociatePublicIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodeAssociatePublicIpAddress
	}).(pulumi.BoolPtrOutput)
}

// Public key material for SSH access to worker nodes. See allowed formats at:
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
// If not provided, no SSH access is enabled on VMs.
func (o ClusterNodeGroupOptionsPtrOutput) NodePublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodePublicKey
	}).(pulumi.StringPtrOutput)
}

// The size in GiB of a cluster node's root volume. Defaults to 20.
func (o ClusterNodeGroupOptionsPtrOutput) NodeRootVolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *int {
		if v == nil {
			return nil
		}
		return v.NodeRootVolumeSize
	}).(pulumi.IntPtrOutput)
}

// The security group for the worker node group to communicate with the cluster.
//
// This security group requires specific inbound and outbound rules.
//
// See for more details:
// https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
//
// Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// The set of subnets to override and use for the worker node group.
//
// Setting this option overrides which subnets to use for the worker node group, regardless if the cluster's `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
func (o ClusterNodeGroupOptionsPtrOutput) NodeSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) []string {
		if v == nil {
			return nil
		}
		return v.NodeSubnetIds
	}).(pulumi.StringArrayOutput)
}

// Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserData
	}).(pulumi.StringPtrOutput)
}

// User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
//
// See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
func (o ClusterNodeGroupOptionsPtrOutput) NodeUserDataOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.NodeUserDataOverride
	}).(pulumi.StringPtrOutput)
}

// Bidding price for spot instance. If set, only spot instances will be added as worker node.
func (o ClusterNodeGroupOptionsPtrOutput) SpotPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.SpotPrice
	}).(pulumi.StringPtrOutput)
}

// Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
func (o ClusterNodeGroupOptionsPtrOutput) Taints() TaintMapOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) map[string]Taint {
		if v == nil {
			return nil
		}
		return v.Taints
	}).(TaintMapOutput)
}

// Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
func (o ClusterNodeGroupOptionsPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterNodeGroupOptions) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreData struct {
	AwsProvider           *aws.Provider                      `pulumi:"awsProvider"`
	Cluster               eks.Cluster                        `pulumi:"cluster"`
	ClusterSecurityGroup  ec2.SecurityGroup                  `pulumi:"clusterSecurityGroup"`
	EksNodeAccess         *corev1.ConfigMap                  `pulumi:"eksNodeAccess"`
	EncryptionConfig      *eks.ClusterEncryptionConfig       `pulumi:"encryptionConfig"`
	Endpoint              string                             `pulumi:"endpoint"`
	FargateProfile        *eks.FargateProfile                `pulumi:"fargateProfile"`
	InstanceRoles         []*iam.Role                        `pulumi:"instanceRoles"`
	Kubeconfig            interface{}                        `pulumi:"kubeconfig"`
	NodeGroupOptions      ClusterNodeGroupOptions            `pulumi:"nodeGroupOptions"`
	NodeSecurityGroupTags map[string]string                  `pulumi:"nodeSecurityGroupTags"`
	OidcProvider          *iam.OpenIdConnectProvider         `pulumi:"oidcProvider"`
	PrivateSubnetIds      []string                           `pulumi:"privateSubnetIds"`
	Provider              kubernetes.Provider                `pulumi:"provider"`
	PublicSubnetIds       []string                           `pulumi:"publicSubnetIds"`
	StorageClasses        map[string]*storagev1.StorageClass `pulumi:"storageClasses"`
	SubnetIds             []string                           `pulumi:"subnetIds"`
	Tags                  map[string]string                  `pulumi:"tags"`
	VpcCni                *VpcCni                            `pulumi:"vpcCni"`
	VpcId                 string                             `pulumi:"vpcId"`
}

// CoreDataInput is an input type that accepts CoreDataArgs and CoreDataOutput values.
// You can construct a concrete instance of `CoreDataInput` via:
//
//          CoreDataArgs{...}
type CoreDataInput interface {
	pulumi.Input

	ToCoreDataOutput() CoreDataOutput
	ToCoreDataOutputWithContext(context.Context) CoreDataOutput
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreDataArgs struct {
	AwsProvider           aws.ProviderInput                   `pulumi:"awsProvider"`
	Cluster               eks.ClusterInput                    `pulumi:"cluster"`
	ClusterSecurityGroup  ec2.SecurityGroupInput              `pulumi:"clusterSecurityGroup"`
	EksNodeAccess         corev1.ConfigMapInput               `pulumi:"eksNodeAccess"`
	EncryptionConfig      eks.ClusterEncryptionConfigPtrInput `pulumi:"encryptionConfig"`
	Endpoint              pulumi.StringInput                  `pulumi:"endpoint"`
	FargateProfile        eks.FargateProfileInput             `pulumi:"fargateProfile"`
	InstanceRoles         iam.RoleArrayInput                  `pulumi:"instanceRoles"`
	Kubeconfig            pulumi.Input                        `pulumi:"kubeconfig"`
	NodeGroupOptions      ClusterNodeGroupOptionsInput        `pulumi:"nodeGroupOptions"`
	NodeSecurityGroupTags pulumi.StringMapInput               `pulumi:"nodeSecurityGroupTags"`
	OidcProvider          iam.OpenIdConnectProviderInput      `pulumi:"oidcProvider"`
	PrivateSubnetIds      pulumi.StringArrayInput             `pulumi:"privateSubnetIds"`
	Provider              kubernetes.ProviderInput            `pulumi:"provider"`
	PublicSubnetIds       pulumi.StringArrayInput             `pulumi:"publicSubnetIds"`
	StorageClasses        storagev1.StorageClassMapInput      `pulumi:"storageClasses"`
	SubnetIds             pulumi.StringArrayInput             `pulumi:"subnetIds"`
	Tags                  pulumi.StringMapInput               `pulumi:"tags"`
	VpcCni                VpcCniInput                         `pulumi:"vpcCni"`
	VpcId                 pulumi.StringInput                  `pulumi:"vpcId"`
}

func (CoreDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreData)(nil)).Elem()
}

func (i CoreDataArgs) ToCoreDataOutput() CoreDataOutput {
	return i.ToCoreDataOutputWithContext(context.Background())
}

func (i CoreDataArgs) ToCoreDataOutputWithContext(ctx context.Context) CoreDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDataOutput)
}

func (i CoreDataArgs) ToCoreDataPtrOutput() CoreDataPtrOutput {
	return i.ToCoreDataPtrOutputWithContext(context.Background())
}

func (i CoreDataArgs) ToCoreDataPtrOutputWithContext(ctx context.Context) CoreDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDataOutput).ToCoreDataPtrOutputWithContext(ctx)
}

// CoreDataPtrInput is an input type that accepts CoreDataArgs, CoreDataPtr and CoreDataPtrOutput values.
// You can construct a concrete instance of `CoreDataPtrInput` via:
//
//          CoreDataArgs{...}
//
//  or:
//
//          nil
type CoreDataPtrInput interface {
	pulumi.Input

	ToCoreDataPtrOutput() CoreDataPtrOutput
	ToCoreDataPtrOutputWithContext(context.Context) CoreDataPtrOutput
}

type coreDataPtrType CoreDataArgs

func CoreDataPtr(v *CoreDataArgs) CoreDataPtrInput {
	return (*coreDataPtrType)(v)
}

func (*coreDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreData)(nil)).Elem()
}

func (i *coreDataPtrType) ToCoreDataPtrOutput() CoreDataPtrOutput {
	return i.ToCoreDataPtrOutputWithContext(context.Background())
}

func (i *coreDataPtrType) ToCoreDataPtrOutputWithContext(ctx context.Context) CoreDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDataPtrOutput)
}

// Defines the core set of data associated with an EKS cluster, including the network in which it runs.
type CoreDataOutput struct{ *pulumi.OutputState }

func (CoreDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreData)(nil)).Elem()
}

func (o CoreDataOutput) ToCoreDataOutput() CoreDataOutput {
	return o
}

func (o CoreDataOutput) ToCoreDataOutputWithContext(ctx context.Context) CoreDataOutput {
	return o
}

func (o CoreDataOutput) ToCoreDataPtrOutput() CoreDataPtrOutput {
	return o.ToCoreDataPtrOutputWithContext(context.Background())
}

func (o CoreDataOutput) ToCoreDataPtrOutputWithContext(ctx context.Context) CoreDataPtrOutput {
	return o.ApplyT(func(v CoreData) *CoreData {
		return &v
	}).(CoreDataPtrOutput)
}
func (o CoreDataOutput) AwsProvider() aws.ProviderOutput {
	return o.ApplyT(func(v CoreData) *aws.Provider { return v.AwsProvider }).(aws.ProviderOutput)
}

func (o CoreDataOutput) Cluster() eks.ClusterOutput {
	return o.ApplyT(func(v CoreData) eks.Cluster { return v.Cluster }).(eks.ClusterOutput)
}

func (o CoreDataOutput) ClusterSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v CoreData) ec2.SecurityGroup { return v.ClusterSecurityGroup }).(ec2.SecurityGroupOutput)
}

func (o CoreDataOutput) EksNodeAccess() corev1.ConfigMapOutput {
	return o.ApplyT(func(v CoreData) *corev1.ConfigMap { return v.EksNodeAccess }).(corev1.ConfigMapOutput)
}

func (o CoreDataOutput) EncryptionConfig() eks.ClusterEncryptionConfigPtrOutput {
	return o.ApplyT(func(v CoreData) *eks.ClusterEncryptionConfig { return v.EncryptionConfig }).(eks.ClusterEncryptionConfigPtrOutput)
}

func (o CoreDataOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.Endpoint }).(pulumi.StringOutput)
}

func (o CoreDataOutput) FargateProfile() eks.FargateProfileOutput {
	return o.ApplyT(func(v CoreData) *eks.FargateProfile { return v.FargateProfile }).(eks.FargateProfileOutput)
}

func (o CoreDataOutput) InstanceRoles() iam.RoleArrayOutput {
	return o.ApplyT(func(v CoreData) []*iam.Role { return v.InstanceRoles }).(iam.RoleArrayOutput)
}

func (o CoreDataOutput) Kubeconfig() pulumi.AnyOutput {
	return o.ApplyT(func(v CoreData) interface{} { return v.Kubeconfig }).(pulumi.AnyOutput)
}

func (o CoreDataOutput) NodeGroupOptions() ClusterNodeGroupOptionsOutput {
	return o.ApplyT(func(v CoreData) ClusterNodeGroupOptions { return v.NodeGroupOptions }).(ClusterNodeGroupOptionsOutput)
}

func (o CoreDataOutput) NodeSecurityGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.NodeSecurityGroupTags }).(pulumi.StringMapOutput)
}

func (o CoreDataOutput) OidcProvider() iam.OpenIdConnectProviderOutput {
	return o.ApplyT(func(v CoreData) *iam.OpenIdConnectProvider { return v.OidcProvider }).(iam.OpenIdConnectProviderOutput)
}

func (o CoreDataOutput) PrivateSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PrivateSubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) Provider() kubernetes.ProviderOutput {
	return o.ApplyT(func(v CoreData) kubernetes.Provider { return v.Provider }).(kubernetes.ProviderOutput)
}

func (o CoreDataOutput) PublicSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.PublicSubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) StorageClasses() storagev1.StorageClassMapOutput {
	return o.ApplyT(func(v CoreData) map[string]*storagev1.StorageClass { return v.StorageClasses }).(storagev1.StorageClassMapOutput)
}

func (o CoreDataOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreData) []string { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

func (o CoreDataOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreData) map[string]string { return v.Tags }).(pulumi.StringMapOutput)
}

func (o CoreDataOutput) VpcCni() VpcCniOutput {
	return o.ApplyT(func(v CoreData) *VpcCni { return v.VpcCni }).(VpcCniOutput)
}

func (o CoreDataOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v CoreData) string { return v.VpcId }).(pulumi.StringOutput)
}

type CoreDataPtrOutput struct{ *pulumi.OutputState }

func (CoreDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreData)(nil)).Elem()
}

func (o CoreDataPtrOutput) ToCoreDataPtrOutput() CoreDataPtrOutput {
	return o
}

func (o CoreDataPtrOutput) ToCoreDataPtrOutputWithContext(ctx context.Context) CoreDataPtrOutput {
	return o
}

func (o CoreDataPtrOutput) Elem() CoreDataOutput {
	return o.ApplyT(func(v *CoreData) CoreData { return *v }).(CoreDataOutput)
}

func (o CoreDataPtrOutput) AwsProvider() aws.ProviderOutput {
	return o.ApplyT(func(v *CoreData) *aws.Provider {
		if v == nil {
			return nil
		}
		return v.AwsProvider
	}).(aws.ProviderOutput)
}

func (o CoreDataPtrOutput) Cluster() eks.ClusterOutput {
	return o.ApplyT(func(v *CoreData) *eks.Cluster {
		if v == nil {
			return nil
		}
		return &v.Cluster
	}).(eks.ClusterOutput)
}

func (o CoreDataPtrOutput) ClusterSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *CoreData) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return &v.ClusterSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

func (o CoreDataPtrOutput) EksNodeAccess() corev1.ConfigMapOutput {
	return o.ApplyT(func(v *CoreData) *corev1.ConfigMap {
		if v == nil {
			return nil
		}
		return v.EksNodeAccess
	}).(corev1.ConfigMapOutput)
}

func (o CoreDataPtrOutput) EncryptionConfig() eks.ClusterEncryptionConfigPtrOutput {
	return o.ApplyT(func(v *CoreData) *eks.ClusterEncryptionConfig {
		if v == nil {
			return nil
		}
		return v.EncryptionConfig
	}).(eks.ClusterEncryptionConfigPtrOutput)
}

func (o CoreDataPtrOutput) Endpoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreData) *string {
		if v == nil {
			return nil
		}
		return &v.Endpoint
	}).(pulumi.StringPtrOutput)
}

func (o CoreDataPtrOutput) FargateProfile() eks.FargateProfileOutput {
	return o.ApplyT(func(v *CoreData) *eks.FargateProfile {
		if v == nil {
			return nil
		}
		return v.FargateProfile
	}).(eks.FargateProfileOutput)
}

func (o CoreDataPtrOutput) InstanceRoles() iam.RoleArrayOutput {
	return o.ApplyT(func(v *CoreData) []*iam.Role {
		if v == nil {
			return nil
		}
		return v.InstanceRoles
	}).(iam.RoleArrayOutput)
}

func (o CoreDataPtrOutput) Kubeconfig() pulumi.AnyOutput {
	return o.ApplyT(func(v *CoreData) interface{} {
		if v == nil {
			return nil
		}
		return v.Kubeconfig
	}).(pulumi.AnyOutput)
}

func (o CoreDataPtrOutput) NodeGroupOptions() ClusterNodeGroupOptionsPtrOutput {
	return o.ApplyT(func(v *CoreData) *ClusterNodeGroupOptions {
		if v == nil {
			return nil
		}
		return &v.NodeGroupOptions
	}).(ClusterNodeGroupOptionsPtrOutput)
}

func (o CoreDataPtrOutput) NodeSecurityGroupTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreData) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSecurityGroupTags
	}).(pulumi.StringMapOutput)
}

func (o CoreDataPtrOutput) OidcProvider() iam.OpenIdConnectProviderOutput {
	return o.ApplyT(func(v *CoreData) *iam.OpenIdConnectProvider {
		if v == nil {
			return nil
		}
		return v.OidcProvider
	}).(iam.OpenIdConnectProviderOutput)
}

func (o CoreDataPtrOutput) PrivateSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CoreData) []string {
		if v == nil {
			return nil
		}
		return v.PrivateSubnetIds
	}).(pulumi.StringArrayOutput)
}

func (o CoreDataPtrOutput) Provider() kubernetes.ProviderOutput {
	return o.ApplyT(func(v *CoreData) *kubernetes.Provider {
		if v == nil {
			return nil
		}
		return &v.Provider
	}).(kubernetes.ProviderOutput)
}

func (o CoreDataPtrOutput) PublicSubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CoreData) []string {
		if v == nil {
			return nil
		}
		return v.PublicSubnetIds
	}).(pulumi.StringArrayOutput)
}

func (o CoreDataPtrOutput) StorageClasses() storagev1.StorageClassMapOutput {
	return o.ApplyT(func(v *CoreData) map[string]*storagev1.StorageClass {
		if v == nil {
			return nil
		}
		return v.StorageClasses
	}).(storagev1.StorageClassMapOutput)
}

func (o CoreDataPtrOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CoreData) []string {
		if v == nil {
			return nil
		}
		return v.SubnetIds
	}).(pulumi.StringArrayOutput)
}

func (o CoreDataPtrOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreData) map[string]string {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(pulumi.StringMapOutput)
}

func (o CoreDataPtrOutput) VpcCni() VpcCniOutput {
	return o.ApplyT(func(v *CoreData) *VpcCni {
		if v == nil {
			return nil
		}
		return v.VpcCni
	}).(VpcCniOutput)
}

func (o CoreDataPtrOutput) VpcId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreData) *string {
		if v == nil {
			return nil
		}
		return &v.VpcId
	}).(pulumi.StringPtrOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProvider struct {
	Provider aws.Provider `pulumi:"provider"`
	Role     iam.Role     `pulumi:"role"`
}

// CreationRoleProviderInput is an input type that accepts CreationRoleProviderArgs and CreationRoleProviderOutput values.
// You can construct a concrete instance of `CreationRoleProviderInput` via:
//
//          CreationRoleProviderArgs{...}
type CreationRoleProviderInput interface {
	pulumi.Input

	ToCreationRoleProviderOutput() CreationRoleProviderOutput
	ToCreationRoleProviderOutputWithContext(context.Context) CreationRoleProviderOutput
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProviderArgs struct {
	Provider aws.ProviderInput `pulumi:"provider"`
	Role     iam.RoleInput     `pulumi:"role"`
}

func (CreationRoleProviderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return i.ToCreationRoleProviderOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput)
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i CreationRoleProviderArgs) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderOutput).ToCreationRoleProviderPtrOutputWithContext(ctx)
}

// CreationRoleProviderPtrInput is an input type that accepts CreationRoleProviderArgs, CreationRoleProviderPtr and CreationRoleProviderPtrOutput values.
// You can construct a concrete instance of `CreationRoleProviderPtrInput` via:
//
//          CreationRoleProviderArgs{...}
//
//  or:
//
//          nil
type CreationRoleProviderPtrInput interface {
	pulumi.Input

	ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput
	ToCreationRoleProviderPtrOutputWithContext(context.Context) CreationRoleProviderPtrOutput
}

type creationRoleProviderPtrType CreationRoleProviderArgs

func CreationRoleProviderPtr(v *CreationRoleProviderArgs) CreationRoleProviderPtrInput {
	return (*creationRoleProviderPtrType)(v)
}

func (*creationRoleProviderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return i.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (i *creationRoleProviderPtrType) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CreationRoleProviderPtrOutput)
}

// Contains the AWS Role and Provider necessary to override the `[system:master]` entity ARN. This is an optional argument used when creating `Cluster`. Read more: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
type CreationRoleProviderOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutput() CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderOutputWithContext(ctx context.Context) CreationRoleProviderOutput {
	return o
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o.ToCreationRoleProviderPtrOutputWithContext(context.Background())
}

func (o CreationRoleProviderOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o.ApplyT(func(v CreationRoleProvider) *CreationRoleProvider {
		return &v
	}).(CreationRoleProviderPtrOutput)
}
func (o CreationRoleProviderOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v CreationRoleProvider) aws.Provider { return v.Provider }).(aws.ProviderOutput)
}

func (o CreationRoleProviderOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v CreationRoleProvider) iam.Role { return v.Role }).(iam.RoleOutput)
}

type CreationRoleProviderPtrOutput struct{ *pulumi.OutputState }

func (CreationRoleProviderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CreationRoleProvider)(nil)).Elem()
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutput() CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) ToCreationRoleProviderPtrOutputWithContext(ctx context.Context) CreationRoleProviderPtrOutput {
	return o
}

func (o CreationRoleProviderPtrOutput) Elem() CreationRoleProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) CreationRoleProvider { return *v }).(CreationRoleProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Provider() aws.ProviderOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *aws.Provider {
		if v == nil {
			return nil
		}
		return &v.Provider
	}).(aws.ProviderOutput)
}

func (o CreationRoleProviderPtrOutput) Role() iam.RoleOutput {
	return o.ApplyT(func(v *CreationRoleProvider) *iam.Role {
		if v == nil {
			return nil
		}
		return &v.Role
	}).(iam.RoleOutput)
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfile struct {
	// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
	PodExecutionRoleArn *string `pulumi:"podExecutionRoleArn"`
	// Specify the namespace and label selectors to use for launching pods into Fargate.
	Selectors []*eks.FargateProfileSelector `pulumi:"selectors"`
	// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
	SubnetIds []string `pulumi:"subnetIds"`
}

// FargateProfileInput is an input type that accepts FargateProfileArgs and FargateProfileOutput values.
// You can construct a concrete instance of `FargateProfileInput` via:
//
//          FargateProfileArgs{...}
type FargateProfileInput interface {
	pulumi.Input

	ToFargateProfileOutput() FargateProfileOutput
	ToFargateProfileOutputWithContext(context.Context) FargateProfileOutput
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfileArgs struct {
	// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
	PodExecutionRoleArn pulumi.StringPtrInput `pulumi:"podExecutionRoleArn"`
	// Specify the namespace and label selectors to use for launching pods into Fargate.
	Selectors eks.FargateProfileSelectorArrayInput `pulumi:"selectors"`
	// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
	SubnetIds pulumi.StringArrayInput `pulumi:"subnetIds"`
}

func (FargateProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FargateProfile)(nil)).Elem()
}

func (i FargateProfileArgs) ToFargateProfileOutput() FargateProfileOutput {
	return i.ToFargateProfileOutputWithContext(context.Background())
}

func (i FargateProfileArgs) ToFargateProfileOutputWithContext(ctx context.Context) FargateProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateProfileOutput)
}

// Defines how Kubernetes pods are executed in Fargate. See aws.eks.FargateProfileArgs for reference.
type FargateProfileOutput struct{ *pulumi.OutputState }

func (FargateProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FargateProfile)(nil)).Elem()
}

func (o FargateProfileOutput) ToFargateProfileOutput() FargateProfileOutput {
	return o
}

func (o FargateProfileOutput) ToFargateProfileOutputWithContext(ctx context.Context) FargateProfileOutput {
	return o
}

// Specify a custom role to use for executing pods in Fargate. Defaults to creating a new role with the `arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy` policy attached.
func (o FargateProfileOutput) PodExecutionRoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FargateProfile) *string { return v.PodExecutionRoleArn }).(pulumi.StringPtrOutput)
}

// Specify the namespace and label selectors to use for launching pods into Fargate.
func (o FargateProfileOutput) Selectors() eks.FargateProfileSelectorArrayOutput {
	return o.ApplyT(func(v FargateProfile) []*eks.FargateProfileSelector { return v.Selectors }).(eks.FargateProfileSelectorArrayOutput)
}

// Specify the subnets in which to execute Fargate tasks for pods. Defaults to the private subnets associated with the cluster.
func (o FargateProfileOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FargateProfile) []string { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//   1. Assume a role on the default account caller,
//   2. Use an AWS creds profile instead of the default account caller,
//   3. Use an AWS creds creds profile instead of the default account caller,
//      and then assume a given role on the profile. This scenario is also
//      possible by only using a profile, iff the profile includes a role to
//      assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptions struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName *string `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn *string `pulumi:"roleArn"`
}

// KubeconfigOptionsInput is an input type that accepts KubeconfigOptionsArgs and KubeconfigOptionsOutput values.
// You can construct a concrete instance of `KubeconfigOptionsInput` via:
//
//          KubeconfigOptionsArgs{...}
type KubeconfigOptionsInput interface {
	pulumi.Input

	ToKubeconfigOptionsOutput() KubeconfigOptionsOutput
	ToKubeconfigOptionsOutputWithContext(context.Context) KubeconfigOptionsOutput
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//   1. Assume a role on the default account caller,
//   2. Use an AWS creds profile instead of the default account caller,
//   3. Use an AWS creds creds profile instead of the default account caller,
//      and then assume a given role on the profile. This scenario is also
//      possible by only using a profile, iff the profile includes a role to
//      assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsArgs struct {
	// AWS credential profile name to always use instead of the default AWS credential provider chain.
	//
	// The profile is passed to kubeconfig as an authentication environment setting.
	ProfileName pulumi.StringPtrInput `pulumi:"profileName"`
	// Role ARN to assume instead of the default AWS credential provider chain.
	//
	// The role is passed to kubeconfig as an authentication exec argument.
	RoleArn pulumi.StringPtrInput `pulumi:"roleArn"`
}

func (KubeconfigOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return i.ToKubeconfigOptionsOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput)
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i KubeconfigOptionsArgs) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsOutput).ToKubeconfigOptionsPtrOutputWithContext(ctx)
}

// KubeconfigOptionsPtrInput is an input type that accepts KubeconfigOptionsArgs, KubeconfigOptionsPtr and KubeconfigOptionsPtrOutput values.
// You can construct a concrete instance of `KubeconfigOptionsPtrInput` via:
//
//          KubeconfigOptionsArgs{...}
//
//  or:
//
//          nil
type KubeconfigOptionsPtrInput interface {
	pulumi.Input

	ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput
	ToKubeconfigOptionsPtrOutputWithContext(context.Context) KubeconfigOptionsPtrOutput
}

type kubeconfigOptionsPtrType KubeconfigOptionsArgs

func KubeconfigOptionsPtr(v *KubeconfigOptionsArgs) KubeconfigOptionsPtrInput {
	return (*kubeconfigOptionsPtrType)(v)
}

func (*kubeconfigOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return i.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (i *kubeconfigOptionsPtrType) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubeconfigOptionsPtrOutput)
}

// Represents the AWS credentials to scope a given kubeconfig when using a non-default credential chain.
//
// The options can be used independently, or additively.
//
// A scoped kubeconfig is necessary for certain auth scenarios. For example:
//   1. Assume a role on the default account caller,
//   2. Use an AWS creds profile instead of the default account caller,
//   3. Use an AWS creds creds profile instead of the default account caller,
//      and then assume a given role on the profile. This scenario is also
//      possible by only using a profile, iff the profile includes a role to
//      assume in its settings.
//
// See for more details:
// - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html
// - https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html
type KubeconfigOptionsOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutput() KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsOutputWithContext(ctx context.Context) KubeconfigOptionsOutput {
	return o
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o.ToKubeconfigOptionsPtrOutputWithContext(context.Background())
}

func (o KubeconfigOptionsOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *KubeconfigOptions {
		return &v
	}).(KubeconfigOptionsPtrOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.ProfileName }).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KubeconfigOptions) *string { return v.RoleArn }).(pulumi.StringPtrOutput)
}

type KubeconfigOptionsPtrOutput struct{ *pulumi.OutputState }

func (KubeconfigOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubeconfigOptions)(nil)).Elem()
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutput() KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) ToKubeconfigOptionsPtrOutputWithContext(ctx context.Context) KubeconfigOptionsPtrOutput {
	return o
}

func (o KubeconfigOptionsPtrOutput) Elem() KubeconfigOptionsOutput {
	return o.ApplyT(func(v *KubeconfigOptions) KubeconfigOptions { return *v }).(KubeconfigOptionsOutput)
}

// AWS credential profile name to always use instead of the default AWS credential provider chain.
//
// The profile is passed to kubeconfig as an authentication environment setting.
func (o KubeconfigOptionsPtrOutput) ProfileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.ProfileName
	}).(pulumi.StringPtrOutput)
}

// Role ARN to assume instead of the default AWS credential provider chain.
//
// The role is passed to kubeconfig as an authentication exec argument.
func (o KubeconfigOptionsPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubeconfigOptions) *string {
		if v == nil {
			return nil
		}
		return v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupData struct {
	// The AutoScalingGroup name for the node group.
	AutoScalingGroupName string `pulumi:"autoScalingGroupName"`
	// The CloudFormation Stack which defines the Node AutoScalingGroup.
	CfnStack cloudformation.Stack `pulumi:"cfnStack"`
	// The additional security groups for the node group that captures user-specific rules.
	ExtraNodeSecurityGroups []*ec2.SecurityGroup `pulumi:"extraNodeSecurityGroups"`
	// The security group for the node group to communicate with the cluster.
	NodeSecurityGroup ec2.SecurityGroup `pulumi:"nodeSecurityGroup"`
}

// NodeGroupDataInput is an input type that accepts NodeGroupDataArgs and NodeGroupDataOutput values.
// You can construct a concrete instance of `NodeGroupDataInput` via:
//
//          NodeGroupDataArgs{...}
type NodeGroupDataInput interface {
	pulumi.Input

	ToNodeGroupDataOutput() NodeGroupDataOutput
	ToNodeGroupDataOutputWithContext(context.Context) NodeGroupDataOutput
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupDataArgs struct {
	// The AutoScalingGroup name for the node group.
	AutoScalingGroupName pulumi.StringInput `pulumi:"autoScalingGroupName"`
	// The CloudFormation Stack which defines the Node AutoScalingGroup.
	CfnStack cloudformation.StackInput `pulumi:"cfnStack"`
	// The additional security groups for the node group that captures user-specific rules.
	ExtraNodeSecurityGroups ec2.SecurityGroupArrayInput `pulumi:"extraNodeSecurityGroups"`
	// The security group for the node group to communicate with the cluster.
	NodeSecurityGroup ec2.SecurityGroupInput `pulumi:"nodeSecurityGroup"`
}

func (NodeGroupDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeGroupData)(nil)).Elem()
}

func (i NodeGroupDataArgs) ToNodeGroupDataOutput() NodeGroupDataOutput {
	return i.ToNodeGroupDataOutputWithContext(context.Background())
}

func (i NodeGroupDataArgs) ToNodeGroupDataOutputWithContext(ctx context.Context) NodeGroupDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupDataOutput)
}

func (i NodeGroupDataArgs) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return i.ToNodeGroupDataPtrOutputWithContext(context.Background())
}

func (i NodeGroupDataArgs) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupDataOutput).ToNodeGroupDataPtrOutputWithContext(ctx)
}

// NodeGroupDataPtrInput is an input type that accepts NodeGroupDataArgs, NodeGroupDataPtr and NodeGroupDataPtrOutput values.
// You can construct a concrete instance of `NodeGroupDataPtrInput` via:
//
//          NodeGroupDataArgs{...}
//
//  or:
//
//          nil
type NodeGroupDataPtrInput interface {
	pulumi.Input

	ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput
	ToNodeGroupDataPtrOutputWithContext(context.Context) NodeGroupDataPtrOutput
}

type nodeGroupDataPtrType NodeGroupDataArgs

func NodeGroupDataPtr(v *NodeGroupDataArgs) NodeGroupDataPtrInput {
	return (*nodeGroupDataPtrType)(v)
}

func (*nodeGroupDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroupData)(nil)).Elem()
}

func (i *nodeGroupDataPtrType) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return i.ToNodeGroupDataPtrOutputWithContext(context.Background())
}

func (i *nodeGroupDataPtrType) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeGroupDataPtrOutput)
}

// NodeGroupData describes the resources created for the given NodeGroup.
type NodeGroupDataOutput struct{ *pulumi.OutputState }

func (NodeGroupDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutput() NodeGroupDataOutput {
	return o
}

func (o NodeGroupDataOutput) ToNodeGroupDataOutputWithContext(ctx context.Context) NodeGroupDataOutput {
	return o
}

func (o NodeGroupDataOutput) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return o.ToNodeGroupDataPtrOutputWithContext(context.Background())
}

func (o NodeGroupDataOutput) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return o.ApplyT(func(v NodeGroupData) *NodeGroupData {
		return &v
	}).(NodeGroupDataPtrOutput)
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataOutput) AutoScalingGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v NodeGroupData) string { return v.AutoScalingGroupName }).(pulumi.StringOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v NodeGroupData) cloudformation.Stack { return v.CfnStack }).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v NodeGroupData) []*ec2.SecurityGroup { return v.ExtraNodeSecurityGroups }).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v NodeGroupData) ec2.SecurityGroup { return v.NodeSecurityGroup }).(ec2.SecurityGroupOutput)
}

type NodeGroupDataPtrOutput struct{ *pulumi.OutputState }

func (NodeGroupDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeGroupData)(nil)).Elem()
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutput() NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) ToNodeGroupDataPtrOutputWithContext(ctx context.Context) NodeGroupDataPtrOutput {
	return o
}

func (o NodeGroupDataPtrOutput) Elem() NodeGroupDataOutput {
	return o.ApplyT(func(v *NodeGroupData) NodeGroupData { return *v }).(NodeGroupDataOutput)
}

// The AutoScalingGroup name for the node group.
func (o NodeGroupDataPtrOutput) AutoScalingGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeGroupData) *string {
		if v == nil {
			return nil
		}
		return &v.AutoScalingGroupName
	}).(pulumi.StringPtrOutput)
}

// The CloudFormation Stack which defines the Node AutoScalingGroup.
func (o NodeGroupDataPtrOutput) CfnStack() cloudformation.StackOutput {
	return o.ApplyT(func(v *NodeGroupData) *cloudformation.Stack {
		if v == nil {
			return nil
		}
		return &v.CfnStack
	}).(cloudformation.StackOutput)
}

// The additional security groups for the node group that captures user-specific rules.
func (o NodeGroupDataPtrOutput) ExtraNodeSecurityGroups() ec2.SecurityGroupArrayOutput {
	return o.ApplyT(func(v *NodeGroupData) []*ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return v.ExtraNodeSecurityGroups
	}).(ec2.SecurityGroupArrayOutput)
}

// The security group for the node group to communicate with the cluster.
func (o NodeGroupDataPtrOutput) NodeSecurityGroup() ec2.SecurityGroupOutput {
	return o.ApplyT(func(v *NodeGroupData) *ec2.SecurityGroup {
		if v == nil {
			return nil
		}
		return &v.NodeSecurityGroup
	}).(ec2.SecurityGroupOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMapping struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn string `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username string `pulumi:"username"`
}

// RoleMappingInput is an input type that accepts RoleMappingArgs and RoleMappingOutput values.
// You can construct a concrete instance of `RoleMappingInput` via:
//
//          RoleMappingArgs{...}
type RoleMappingInput interface {
	pulumi.Input

	ToRoleMappingOutput() RoleMappingOutput
	ToRoleMappingOutputWithContext(context.Context) RoleMappingOutput
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingArgs struct {
	// A list of groups within Kubernetes to which the role is mapped.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM role to add.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
	// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
	Username pulumi.StringInput `pulumi:"username"`
}

func (RoleMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (i RoleMappingArgs) ToRoleMappingOutput() RoleMappingOutput {
	return i.ToRoleMappingOutputWithContext(context.Background())
}

func (i RoleMappingArgs) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingOutput)
}

// RoleMappingArrayInput is an input type that accepts RoleMappingArray and RoleMappingArrayOutput values.
// You can construct a concrete instance of `RoleMappingArrayInput` via:
//
//          RoleMappingArray{ RoleMappingArgs{...} }
type RoleMappingArrayInput interface {
	pulumi.Input

	ToRoleMappingArrayOutput() RoleMappingArrayOutput
	ToRoleMappingArrayOutputWithContext(context.Context) RoleMappingArrayOutput
}

type RoleMappingArray []RoleMappingInput

func (RoleMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (i RoleMappingArray) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return i.ToRoleMappingArrayOutputWithContext(context.Background())
}

func (i RoleMappingArray) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoleMappingArrayOutput)
}

// Describes a mapping from an AWS IAM role to a Kubernetes user and groups.
type RoleMappingOutput struct{ *pulumi.OutputState }

func (RoleMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RoleMapping)(nil)).Elem()
}

func (o RoleMappingOutput) ToRoleMappingOutput() RoleMappingOutput {
	return o
}

func (o RoleMappingOutput) ToRoleMappingOutputWithContext(ctx context.Context) RoleMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the role is mapped.
func (o RoleMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RoleMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM role to add.
func (o RoleMappingOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.RoleArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM role. By default, the user name is the ARN of the IAM role.
func (o RoleMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v RoleMapping) string { return v.Username }).(pulumi.StringOutput)
}

type RoleMappingArrayOutput struct{ *pulumi.OutputState }

func (RoleMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RoleMapping)(nil)).Elem()
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutput() RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) ToRoleMappingArrayOutputWithContext(ctx context.Context) RoleMappingArrayOutput {
	return o
}

func (o RoleMappingArrayOutput) Index(i pulumi.IntInput) RoleMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RoleMapping {
		return vs[0].([]RoleMapping)[vs[1].(int)]
	}).(RoleMappingOutput)
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClass struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand.
	AllowVolumeExpansion *bool `pulumi:"allowVolumeExpansion"`
	// True if this storage class should be a default storage class for the cluster.
	//
	// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
	//
	// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
	Default *bool `pulumi:"default"`
	// Denotes whether the EBS volume should be encrypted.
	Encrypted *bool `pulumi:"encrypted"`
	// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
	IopsPerGb *int `pulumi:"iopsPerGb"`
	// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions []string `pulumi:"mountOptions"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy *string `pulumi:"reclaimPolicy"`
	// The EBS volume type.
	Type string `pulumi:"type"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode *string `pulumi:"volumeBindingMode"`
	// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
	Zones []string `pulumi:"zones"`
}

// StorageClassInput is an input type that accepts StorageClassArgs and StorageClassOutput values.
// You can construct a concrete instance of `StorageClassInput` via:
//
//          StorageClassArgs{...}
type StorageClassInput interface {
	pulumi.Input

	ToStorageClassOutput() StorageClassOutput
	ToStorageClassOutputWithContext(context.Context) StorageClassOutput
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClassArgs struct {
	// AllowVolumeExpansion shows whether the storage class allow volume expand.
	AllowVolumeExpansion pulumi.BoolPtrInput `pulumi:"allowVolumeExpansion"`
	// True if this storage class should be a default storage class for the cluster.
	//
	// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
	//
	// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
	Default pulumi.BoolPtrInput `pulumi:"default"`
	// Denotes whether the EBS volume should be encrypted.
	Encrypted pulumi.BoolPtrInput `pulumi:"encrypted"`
	// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
	IopsPerGb pulumi.IntPtrInput `pulumi:"iopsPerGb"`
	// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
	KmsKeyId pulumi.StringPtrInput `pulumi:"kmsKeyId"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
	MountOptions pulumi.StringArrayInput `pulumi:"mountOptions"`
	// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
	ReclaimPolicy pulumi.StringPtrInput `pulumi:"reclaimPolicy"`
	// The EBS volume type.
	Type pulumi.StringInput `pulumi:"type"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
	VolumeBindingMode pulumi.StringPtrInput `pulumi:"volumeBindingMode"`
	// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
	Zones pulumi.StringArrayInput `pulumi:"zones"`
}

func (StorageClassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageClass)(nil)).Elem()
}

func (i StorageClassArgs) ToStorageClassOutput() StorageClassOutput {
	return i.ToStorageClassOutputWithContext(context.Background())
}

func (i StorageClassArgs) ToStorageClassOutputWithContext(ctx context.Context) StorageClassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageClassOutput)
}

// StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage classes can be added to a cluster at creation time. One of these storage classes may be configured the default storage class for the cluster.
type StorageClassOutput struct{ *pulumi.OutputState }

func (StorageClassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageClass)(nil)).Elem()
}

func (o StorageClassOutput) ToStorageClassOutput() StorageClassOutput {
	return o
}

func (o StorageClassOutput) ToStorageClassOutputWithContext(ctx context.Context) StorageClassOutput {
	return o
}

// AllowVolumeExpansion shows whether the storage class allow volume expand.
func (o StorageClassOutput) AllowVolumeExpansion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.AllowVolumeExpansion }).(pulumi.BoolPtrOutput)
}

// True if this storage class should be a default storage class for the cluster.
//
// Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
//
// Please note that at most one storage class can be marked as default. If two or more of them are marked as default, a PersistentVolumeClaim without `storageClassName` explicitly specified cannot be created. See: https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
func (o StorageClassOutput) Default() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.Default }).(pulumi.BoolPtrOutput)
}

// Denotes whether the EBS volume should be encrypted.
func (o StorageClassOutput) Encrypted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StorageClass) *bool { return v.Encrypted }).(pulumi.BoolPtrOutput)
}

// I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
func (o StorageClassOutput) IopsPerGb() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StorageClass) *int { return v.IopsPerGb }).(pulumi.IntPtrOutput)
}

// The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is true, a key is generated by AWS.
func (o StorageClassOutput) KmsKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.KmsKeyId }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
func (o StorageClassOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v StorageClass) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one is invalid.
func (o StorageClassOutput) MountOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StorageClass) []string { return v.MountOptions }).(pulumi.StringArrayOutput)
}

// Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.
func (o StorageClassOutput) ReclaimPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.ReclaimPolicy }).(pulumi.StringPtrOutput)
}

// The EBS volume type.
func (o StorageClassOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageClass) string { return v.Type }).(pulumi.StringOutput)
}

// VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound. When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored by servers that enable the VolumeScheduling feature.
func (o StorageClassOutput) VolumeBindingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageClass) *string { return v.VolumeBindingMode }).(pulumi.StringPtrOutput)
}

// The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same time.
func (o StorageClassOutput) Zones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StorageClass) []string { return v.Zones }).(pulumi.StringArrayOutput)
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type Taint struct {
	// The effect of the taint.
	Effect string `pulumi:"effect"`
	// The value of the taint.
	Value string `pulumi:"value"`
}

// TaintInput is an input type that accepts TaintArgs and TaintOutput values.
// You can construct a concrete instance of `TaintInput` via:
//
//          TaintArgs{...}
type TaintInput interface {
	pulumi.Input

	ToTaintOutput() TaintOutput
	ToTaintOutputWithContext(context.Context) TaintOutput
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintArgs struct {
	// The effect of the taint.
	Effect pulumi.StringInput `pulumi:"effect"`
	// The value of the taint.
	Value pulumi.StringInput `pulumi:"value"`
}

func (TaintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (i TaintArgs) ToTaintOutput() TaintOutput {
	return i.ToTaintOutputWithContext(context.Background())
}

func (i TaintArgs) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintOutput)
}

// TaintMapInput is an input type that accepts TaintMap and TaintMapOutput values.
// You can construct a concrete instance of `TaintMapInput` via:
//
//          TaintMap{ "key": TaintArgs{...} }
type TaintMapInput interface {
	pulumi.Input

	ToTaintMapOutput() TaintMapOutput
	ToTaintMapOutputWithContext(context.Context) TaintMapOutput
}

type TaintMap map[string]TaintInput

func (TaintMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (i TaintMap) ToTaintMapOutput() TaintMapOutput {
	return i.ToTaintMapOutputWithContext(context.Background())
}

func (i TaintMap) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaintMapOutput)
}

// Represents a Kubernetes `taint` to apply to all Nodes in a NodeGroup. See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/.
type TaintOutput struct{ *pulumi.OutputState }

func (TaintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Taint)(nil)).Elem()
}

func (o TaintOutput) ToTaintOutput() TaintOutput {
	return o
}

func (o TaintOutput) ToTaintOutputWithContext(ctx context.Context) TaintOutput {
	return o
}

// The effect of the taint.
func (o TaintOutput) Effect() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Effect }).(pulumi.StringOutput)
}

// The value of the taint.
func (o TaintOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v Taint) string { return v.Value }).(pulumi.StringOutput)
}

type TaintMapOutput struct{ *pulumi.OutputState }

func (TaintMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Taint)(nil)).Elem()
}

func (o TaintMapOutput) ToTaintMapOutput() TaintMapOutput {
	return o
}

func (o TaintMapOutput) ToTaintMapOutputWithContext(ctx context.Context) TaintMapOutput {
	return o
}

func (o TaintMapOutput) MapIndex(k pulumi.StringInput) TaintOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Taint {
		return vs[0].(map[string]Taint)[vs[1].(string)]
	}).(TaintOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMapping struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups []string `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn string `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username string `pulumi:"username"`
}

// UserMappingInput is an input type that accepts UserMappingArgs and UserMappingOutput values.
// You can construct a concrete instance of `UserMappingInput` via:
//
//          UserMappingArgs{...}
type UserMappingInput interface {
	pulumi.Input

	ToUserMappingOutput() UserMappingOutput
	ToUserMappingOutputWithContext(context.Context) UserMappingOutput
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingArgs struct {
	// A list of groups within Kubernetes to which the user is mapped to.
	Groups pulumi.StringArrayInput `pulumi:"groups"`
	// The ARN of the IAM user to add.
	UserArn pulumi.StringInput `pulumi:"userArn"`
	// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
	Username pulumi.StringInput `pulumi:"username"`
}

func (UserMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (i UserMappingArgs) ToUserMappingOutput() UserMappingOutput {
	return i.ToUserMappingOutputWithContext(context.Background())
}

func (i UserMappingArgs) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingOutput)
}

// UserMappingArrayInput is an input type that accepts UserMappingArray and UserMappingArrayOutput values.
// You can construct a concrete instance of `UserMappingArrayInput` via:
//
//          UserMappingArray{ UserMappingArgs{...} }
type UserMappingArrayInput interface {
	pulumi.Input

	ToUserMappingArrayOutput() UserMappingArrayOutput
	ToUserMappingArrayOutputWithContext(context.Context) UserMappingArrayOutput
}

type UserMappingArray []UserMappingInput

func (UserMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (i UserMappingArray) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return i.ToUserMappingArrayOutputWithContext(context.Background())
}

func (i UserMappingArray) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMappingArrayOutput)
}

// Describes a mapping from an AWS IAM user to a Kubernetes user and groups.
type UserMappingOutput struct{ *pulumi.OutputState }

func (UserMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserMapping)(nil)).Elem()
}

func (o UserMappingOutput) ToUserMappingOutput() UserMappingOutput {
	return o
}

func (o UserMappingOutput) ToUserMappingOutputWithContext(ctx context.Context) UserMappingOutput {
	return o
}

// A list of groups within Kubernetes to which the user is mapped to.
func (o UserMappingOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserMapping) []string { return v.Groups }).(pulumi.StringArrayOutput)
}

// The ARN of the IAM user to add.
func (o UserMappingOutput) UserArn() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.UserArn }).(pulumi.StringOutput)
}

// The user name within Kubernetes to map to the IAM user. By default, the user name is the ARN of the IAM user.
func (o UserMappingOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v UserMapping) string { return v.Username }).(pulumi.StringOutput)
}

type UserMappingArrayOutput struct{ *pulumi.OutputState }

func (UserMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserMapping)(nil)).Elem()
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutput() UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) ToUserMappingArrayOutputWithContext(ctx context.Context) UserMappingArrayOutput {
	return o
}

func (o UserMappingArrayOutput) Index(i pulumi.IntInput) UserMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserMapping {
		return vs[0].([]UserMapping)[vs[1].(int)]
	}).(UserMappingOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptions struct {
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig *bool `pulumi:"customNetworkConfig"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef *string `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu *int `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat *bool `pulumi:"externalSnat"`
	// Specifies the container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image *string `pulumi:"image"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile *string `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel *string `pulumi:"logLevel"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport *bool `pulumi:"nodePortSupport"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix *string `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget *int `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget *int `pulumi:"warmIpTarget"`
}

// VpcCniOptionsInput is an input type that accepts VpcCniOptionsArgs and VpcCniOptionsOutput values.
// You can construct a concrete instance of `VpcCniOptionsInput` via:
//
//          VpcCniOptionsArgs{...}
type VpcCniOptionsInput interface {
	pulumi.Input

	ToVpcCniOptionsOutput() VpcCniOptionsOutput
	ToVpcCniOptionsOutputWithContext(context.Context) VpcCniOptionsOutput
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsArgs struct {
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig pulumi.BoolPtrInput `pulumi:"customNetworkConfig"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef pulumi.StringPtrInput `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu pulumi.IntPtrInput `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat pulumi.BoolPtrInput `pulumi:"externalSnat"`
	// Specifies the container image to use in the AWS CNI cluster DaemonSet.
	//
	// Defaults to the official AWS CNI image in ECR.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile pulumi.StringPtrInput `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel pulumi.StringPtrInput `pulumi:"logLevel"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport pulumi.BoolPtrInput `pulumi:"nodePortSupport"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix pulumi.StringPtrInput `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget pulumi.IntPtrInput `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget pulumi.IntPtrInput `pulumi:"warmIpTarget"`
}

func (VpcCniOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return i.ToVpcCniOptionsOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput)
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i VpcCniOptionsArgs) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsOutput).ToVpcCniOptionsPtrOutputWithContext(ctx)
}

// VpcCniOptionsPtrInput is an input type that accepts VpcCniOptionsArgs, VpcCniOptionsPtr and VpcCniOptionsPtrOutput values.
// You can construct a concrete instance of `VpcCniOptionsPtrInput` via:
//
//          VpcCniOptionsArgs{...}
//
//  or:
//
//          nil
type VpcCniOptionsPtrInput interface {
	pulumi.Input

	ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput
	ToVpcCniOptionsPtrOutputWithContext(context.Context) VpcCniOptionsPtrOutput
}

type vpcCniOptionsPtrType VpcCniOptionsArgs

func VpcCniOptionsPtr(v *VpcCniOptionsArgs) VpcCniOptionsPtrInput {
	return (*vpcCniOptionsPtrType)(v)
}

func (*vpcCniOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return i.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (i *vpcCniOptionsPtrType) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniOptionsPtrOutput)
}

// Describes the configuration options available for the Amazon VPC CNI plugin for Kubernetes.
type VpcCniOptionsOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutput() VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsOutputWithContext(ctx context.Context) VpcCniOptionsOutput {
	return o
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o.ToVpcCniOptionsPtrOutputWithContext(context.Background())
}

func (o VpcCniOptionsOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *VpcCniOptions {
		return &v
	}).(VpcCniOptionsPtrOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.CustomNetworkConfig }).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.EniConfigLabelDef }).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.EniMtu }).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.ExternalSnat }).(pulumi.BoolPtrOutput)
}

// Specifies the container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogFile }).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.LogLevel }).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *bool { return v.NodePortSupport }).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *string { return v.VethPrefix }).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmEniTarget }).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VpcCniOptions) *int { return v.WarmIpTarget }).(pulumi.IntPtrOutput)
}

type VpcCniOptionsPtrOutput struct{ *pulumi.OutputState }

func (VpcCniOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniOptions)(nil)).Elem()
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutput() VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) ToVpcCniOptionsPtrOutputWithContext(ctx context.Context) VpcCniOptionsPtrOutput {
	return o
}

func (o VpcCniOptionsPtrOutput) Elem() VpcCniOptionsOutput {
	return o.ApplyT(func(v *VpcCniOptions) VpcCniOptions { return *v }).(VpcCniOptionsOutput)
}

// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) CustomNetworkConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.CustomNetworkConfig
	}).(pulumi.BoolPtrOutput)
}

// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) EniConfigLabelDef() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.EniConfigLabelDef
	}).(pulumi.StringPtrOutput)
}

// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
//
// Defaults to 9001.
func (o VpcCniOptionsPtrOutput) EniMtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.EniMtu
	}).(pulumi.IntPtrOutput)
}

// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
//
// Defaults to false.
func (o VpcCniOptionsPtrOutput) ExternalSnat() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.ExternalSnat
	}).(pulumi.BoolPtrOutput)
}

// Specifies the container image to use in the AWS CNI cluster DaemonSet.
//
// Defaults to the official AWS CNI image in ECR.
func (o VpcCniOptionsPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Specifies the file path used for logs.
//
// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
func (o VpcCniOptionsPtrOutput) LogFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogFile
	}).(pulumi.StringPtrOutput)
}

// Specifies the log level used for logs.
//
// Defaults to "DEBUG"
// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
func (o VpcCniOptionsPtrOutput) LogLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.LogLevel
	}).(pulumi.StringPtrOutput)
}

// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
//
// Defaults to true.
func (o VpcCniOptionsPtrOutput) NodePortSupport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *bool {
		if v == nil {
			return nil
		}
		return v.NodePortSupport
	}).(pulumi.BoolPtrOutput)
}

// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
//
// The prefix can be at most 4 characters long.
//
// Defaults to "eni".
func (o VpcCniOptionsPtrOutput) VethPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *string {
		if v == nil {
			return nil
		}
		return v.VethPrefix
	}).(pulumi.StringPtrOutput)
}

// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
//
// Defaults to 1.
func (o VpcCniOptionsPtrOutput) WarmEniTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmEniTarget
	}).(pulumi.IntPtrOutput)
}

// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
func (o VpcCniOptionsPtrOutput) WarmIpTarget() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VpcCniOptions) *int {
		if v == nil {
			return nil
		}
		return v.WarmIpTarget
	}).(pulumi.IntPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsOutput{})
	pulumi.RegisterOutputType(ClusterNodeGroupOptionsPtrOutput{})
	pulumi.RegisterOutputType(CoreDataOutput{})
	pulumi.RegisterOutputType(CoreDataPtrOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderOutput{})
	pulumi.RegisterOutputType(CreationRoleProviderPtrOutput{})
	pulumi.RegisterOutputType(FargateProfileOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsOutput{})
	pulumi.RegisterOutputType(KubeconfigOptionsPtrOutput{})
	pulumi.RegisterOutputType(NodeGroupDataOutput{})
	pulumi.RegisterOutputType(NodeGroupDataPtrOutput{})
	pulumi.RegisterOutputType(RoleMappingOutput{})
	pulumi.RegisterOutputType(RoleMappingArrayOutput{})
	pulumi.RegisterOutputType(StorageClassOutput{})
	pulumi.RegisterOutputType(TaintOutput{})
	pulumi.RegisterOutputType(TaintMapOutput{})
	pulumi.RegisterOutputType(UserMappingOutput{})
	pulumi.RegisterOutputType(UserMappingArrayOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsOutput{})
	pulumi.RegisterOutputType(VpcCniOptionsPtrOutput{})
}
