// Code generated by pulumi-gen-eks DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-eks/sdk/v2/go/eks/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Addon manages an EKS add-on.
// For more information about supported add-ons, see: https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html
type Addon struct {
	pulumi.ResourceState
}

// NewAddon registers a new resource with the given unique name, arguments, and options.
func NewAddon(ctx *pulumi.Context,
	name string, args *AddonArgs, opts ...pulumi.ResourceOption) (*Addon, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AddonName == nil {
		return nil, errors.New("invalid value for required argument 'AddonName'")
	}
	if args.Cluster == nil {
		return nil, errors.New("invalid value for required argument 'Cluster'")
	}
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource Addon
	err := ctx.RegisterRemoteComponentResource("eks:index:Addon", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type addonArgs struct {
	// Name of the EKS add-on. The name must match one of the names returned by describe-addon-versions.
	AddonName string `pulumi:"addonName"`
	// The version of the EKS add-on. The version must match one of the versions returned by describe-addon-versions.
	AddonVersion *string `pulumi:"addonVersion"`
	// The target EKS cluster.
	Cluster *Cluster `pulumi:"cluster"`
	// Custom configuration values for addons specified as an object. This object value must match the JSON schema derived from describe-addon-configuration.
	ConfigurationValues map[string]interface{} `pulumi:"configurationValues"`
	// Indicates if you want to preserve the created resources when deleting the EKS add-on.
	Preserve *bool `pulumi:"preserve"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are NONE and OVERWRITE. For more details see the CreateAddon API Docs.
	ResolveConflictsOnCreate *string `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are NONE, OVERWRITE, and PRESERVE. For more details see the UpdateAddon API Docs.
	ResolveConflictsOnUpdate *string `pulumi:"resolveConflictsOnUpdate"`
	// The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see Amazon EKS node IAM role in the Amazon EKS User Guide.
	//
	//                         Note: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see Enabling IAM roles for service accounts on your cluster in the Amazon EKS User Guide.
	ServiceAccountRoleArn *string `pulumi:"serviceAccountRoleArn"`
	// Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags []map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a Addon resource.
type AddonArgs struct {
	// Name of the EKS add-on. The name must match one of the names returned by describe-addon-versions.
	AddonName pulumi.StringInput
	// The version of the EKS add-on. The version must match one of the versions returned by describe-addon-versions.
	AddonVersion pulumi.StringPtrInput
	// The target EKS cluster.
	Cluster ClusterInput
	// Custom configuration values for addons specified as an object. This object value must match the JSON schema derived from describe-addon-configuration.
	ConfigurationValues pulumi.MapInput
	// Indicates if you want to preserve the created resources when deleting the EKS add-on.
	Preserve pulumi.BoolPtrInput
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are NONE and OVERWRITE. For more details see the CreateAddon API Docs.
	ResolveConflictsOnCreate pulumi.StringPtrInput
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value. Valid values are NONE, OVERWRITE, and PRESERVE. For more details see the UpdateAddon API Docs.
	ResolveConflictsOnUpdate pulumi.StringPtrInput
	// The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see Amazon EKS node IAM role in the Amazon EKS User Guide.
	//
	//                         Note: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see Enabling IAM roles for service accounts on your cluster in the Amazon EKS User Guide.
	ServiceAccountRoleArn pulumi.StringPtrInput
	// Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapArrayInput
}

func (AddonArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*addonArgs)(nil)).Elem()
}

type AddonInput interface {
	pulumi.Input

	ToAddonOutput() AddonOutput
	ToAddonOutputWithContext(ctx context.Context) AddonOutput
}

func (*Addon) ElementType() reflect.Type {
	return reflect.TypeOf((**Addon)(nil)).Elem()
}

func (i *Addon) ToAddonOutput() AddonOutput {
	return i.ToAddonOutputWithContext(context.Background())
}

func (i *Addon) ToAddonOutputWithContext(ctx context.Context) AddonOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddonOutput)
}

// AddonArrayInput is an input type that accepts AddonArray and AddonArrayOutput values.
// You can construct a concrete instance of `AddonArrayInput` via:
//
//	AddonArray{ AddonArgs{...} }
type AddonArrayInput interface {
	pulumi.Input

	ToAddonArrayOutput() AddonArrayOutput
	ToAddonArrayOutputWithContext(context.Context) AddonArrayOutput
}

type AddonArray []AddonInput

func (AddonArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Addon)(nil)).Elem()
}

func (i AddonArray) ToAddonArrayOutput() AddonArrayOutput {
	return i.ToAddonArrayOutputWithContext(context.Background())
}

func (i AddonArray) ToAddonArrayOutputWithContext(ctx context.Context) AddonArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddonArrayOutput)
}

// AddonMapInput is an input type that accepts AddonMap and AddonMapOutput values.
// You can construct a concrete instance of `AddonMapInput` via:
//
//	AddonMap{ "key": AddonArgs{...} }
type AddonMapInput interface {
	pulumi.Input

	ToAddonMapOutput() AddonMapOutput
	ToAddonMapOutputWithContext(context.Context) AddonMapOutput
}

type AddonMap map[string]AddonInput

func (AddonMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Addon)(nil)).Elem()
}

func (i AddonMap) ToAddonMapOutput() AddonMapOutput {
	return i.ToAddonMapOutputWithContext(context.Background())
}

func (i AddonMap) ToAddonMapOutputWithContext(ctx context.Context) AddonMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddonMapOutput)
}

type AddonOutput struct{ *pulumi.OutputState }

func (AddonOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Addon)(nil)).Elem()
}

func (o AddonOutput) ToAddonOutput() AddonOutput {
	return o
}

func (o AddonOutput) ToAddonOutputWithContext(ctx context.Context) AddonOutput {
	return o
}

type AddonArrayOutput struct{ *pulumi.OutputState }

func (AddonArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Addon)(nil)).Elem()
}

func (o AddonArrayOutput) ToAddonArrayOutput() AddonArrayOutput {
	return o
}

func (o AddonArrayOutput) ToAddonArrayOutputWithContext(ctx context.Context) AddonArrayOutput {
	return o
}

func (o AddonArrayOutput) Index(i pulumi.IntInput) AddonOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Addon {
		return vs[0].([]*Addon)[vs[1].(int)]
	}).(AddonOutput)
}

type AddonMapOutput struct{ *pulumi.OutputState }

func (AddonMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Addon)(nil)).Elem()
}

func (o AddonMapOutput) ToAddonMapOutput() AddonMapOutput {
	return o
}

func (o AddonMapOutput) ToAddonMapOutputWithContext(ctx context.Context) AddonMapOutput {
	return o
}

func (o AddonMapOutput) MapIndex(k pulumi.StringInput) AddonOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Addon {
		return vs[0].(map[string]*Addon)[vs[1].(string)]
	}).(AddonOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AddonInput)(nil)).Elem(), &Addon{})
	pulumi.RegisterInputType(reflect.TypeOf((*AddonArrayInput)(nil)).Elem(), AddonArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AddonMapInput)(nil)).Elem(), AddonMap{})
	pulumi.RegisterOutputType(AddonOutput{})
	pulumi.RegisterOutputType(AddonArrayOutput{})
	pulumi.RegisterOutputType(AddonMapOutput{})
}
