// Code generated by pulumi-gen-eks DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-eks/sdk/v3/go/eks/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// VpcCniAddon manages the configuration of the Amazon VPC CNI plugin for Kubernetes by leveraging the EKS managed add-on.
// For more information see: https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html
type VpcCniAddon struct {
	pulumi.ResourceState
}

// NewVpcCniAddon registers a new resource with the given unique name, arguments, and options.
func NewVpcCniAddon(ctx *pulumi.Context,
	name string, args *VpcCniAddonArgs, opts ...pulumi.ResourceOption) (*VpcCniAddon, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.ResolveConflictsOnCreate == nil {
		resolveConflictsOnCreate_ := ResolveConflictsOnCreate("OVERWRITE")
		args.ResolveConflictsOnCreate = &resolveConflictsOnCreate_
	}
	if args.ResolveConflictsOnUpdate == nil {
		resolveConflictsOnUpdate_ := ResolveConflictsOnUpdate("OVERWRITE")
		args.ResolveConflictsOnUpdate = &resolveConflictsOnUpdate_
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("eks:index:VpcCni"),
		},
	})
	opts = append(opts, aliases)
	opts = utilities.PkgResourceDefaultOpts(opts)
	var resource VpcCniAddon
	err := ctx.RegisterRemoteComponentResource("eks:index:VpcCniAddon", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type vpcCniAddonArgs struct {
	// The version of the addon to use. If not specified, the latest version of the addon for the cluster's Kubernetes version will be used.
	AddonVersion *string `pulumi:"addonVersion"`
	// The name of the EKS cluster.
	ClusterName string `pulumi:"clusterName"`
	// The Kubernetes version of the cluster. This is used to determine the addon version to use if `addonVersion` is not specified.
	ClusterVersion *string `pulumi:"clusterVersion"`
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter *bool `pulumi:"cniConfigureRpfilter"`
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg *bool `pulumi:"cniCustomNetworkCfg"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat *bool `pulumi:"cniExternalSnat"`
	// Custom configuration values for the vpc-cni addon. This object must match the schema derived from [describe-addon-configuration](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-configuration.html).
	ConfigurationValues map[string]interface{} `pulumi:"configurationValues"`
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig *bool `pulumi:"customNetworkConfig"`
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux *bool `pulumi:"disableTcpEarlyDemux"`
	// Enables using Kubernetes network policies. In Kubernetes, by default, all pod-to-pod communication is allowed. Communication can be restricted with Kubernetes NetworkPolicy objects.
	//
	// See for more information: [Kubernetes Network Policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/).
	EnableNetworkPolicy *bool `pulumi:"enableNetworkPolicy"`
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni *bool `pulumi:"enablePodEni"`
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation *bool `pulumi:"enablePrefixDelegation"`
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef *string `pulumi:"eniConfigLabelDef"`
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu *int `pulumi:"eniMtu"`
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat *bool `pulumi:"externalSnat"`
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile *string `pulumi:"logFile"`
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel *string `pulumi:"logLevel"`
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport *bool `pulumi:"nodePortSupport"`
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate `pulumi:"resolveConflictsOnCreate"`
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value.  Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate `pulumi:"resolveConflictsOnUpdate"`
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged *bool `pulumi:"securityContextPrivileged"`
	// The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role.
	//
	// For more information, see [Amazon EKS node IAM role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html) in the Amazon EKS User Guide.
	//
	// Note: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see [Enabling IAM roles for service accounts on your cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html) in the Amazon EKS User Guide.
	ServiceAccountRoleArn *string `pulumi:"serviceAccountRoleArn"`
	// Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags []map[string]string `pulumi:"tags"`
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix *string `pulumi:"vethPrefix"`
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget *int `pulumi:"warmEniTarget"`
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget *int `pulumi:"warmIpTarget"`
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget *int `pulumi:"warmPrefixTarget"`
}

// The set of arguments for constructing a VpcCniAddon resource.
type VpcCniAddonArgs struct {
	// The version of the addon to use. If not specified, the latest version of the addon for the cluster's Kubernetes version will be used.
	AddonVersion pulumi.StringPtrInput
	// The name of the EKS cluster.
	ClusterName pulumi.StringInput
	// The Kubernetes version of the cluster. This is used to determine the addon version to use if `addonVersion` is not specified.
	ClusterVersion pulumi.StringPtrInput
	// Specifies whether ipamd should configure rp filter for primary interface. Default is `false`.
	CniConfigureRpfilter pulumi.BoolPtrInput
	// Specifies that your pods may use subnets and security groups that are independent of your worker node's VPC configuration. By default, pods share the same subnet and security groups as the worker node's primary interface. Setting this variable to true causes ipamd to use the security groups and VPC subnet in a worker node's ENIConfig for elastic network interface allocation. You must create an ENIConfig custom resource for each subnet that your pods will reside in, and then annotate or label each worker node to use a specific ENIConfig (multiple worker nodes can be annotated or labelled with the same ENIConfig). Worker nodes can only be annotated with a single ENIConfig at a time, and the subnet in the ENIConfig must belong to the same Availability Zone that the worker node resides in. For more information, see CNI Custom Networking in the Amazon EKS User Guide. Default is `false`
	CniCustomNetworkCfg pulumi.BoolPtrInput
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied. Disable SNAT if you need to allow inbound communication to your pods from external VPNs, direct connections, and external VPCs, and your pods do not need to access the Internet directly via an Internet Gateway. However, your nodes must be running in a private subnet and connected to the internet through an AWS NAT Gateway or another external NAT device. Default is `false`
	CniExternalSnat pulumi.BoolPtrInput
	// Custom configuration values for the vpc-cni addon. This object must match the schema derived from [describe-addon-configuration](https://docs.aws.amazon.com/cli/latest/reference/eks/describe-addon-configuration.html).
	ConfigurationValues pulumi.MapInput
	// Specifies that your pods may use subnets and security groups (within the same VPC as your control plane resources) that are independent of your cluster's `resourcesVpcConfig`.
	//
	// Defaults to false.
	CustomNetworkConfig pulumi.BoolPtrInput
	// Allows the kubelet's liveness and readiness probes to connect via TCP when pod ENI is enabled. This will slightly increase local TCP connection latency.
	DisableTcpEarlyDemux pulumi.BoolPtrInput
	// Enables using Kubernetes network policies. In Kubernetes, by default, all pod-to-pod communication is allowed. Communication can be restricted with Kubernetes NetworkPolicy objects.
	//
	// See for more information: [Kubernetes Network Policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/).
	EnableNetworkPolicy pulumi.BoolPtrInput
	// Specifies whether to allow IPAMD to add the `vpc.amazonaws.com/has-trunk-attached` label to the node if the instance has capacity to attach an additional ENI. Default is `false`. If using liveness and readiness probes, you will also need to disable TCP early demux.
	EnablePodEni pulumi.BoolPtrInput
	// IPAMD will start allocating (/28) prefixes to the ENIs with ENABLE_PREFIX_DELEGATION set to true.
	EnablePrefixDelegation pulumi.BoolPtrInput
	// Specifies the ENI_CONFIG_LABEL_DEF environment variable value for worker nodes. This is used to tell Kubernetes to automatically apply the ENIConfig for each Availability Zone
	// Ref: https://docs.aws.amazon.com/eks/latest/userguide/cni-custom-network.html (step 5(c))
	//
	// Defaults to the official AWS CNI image in ECR.
	EniConfigLabelDef pulumi.StringPtrInput
	// Used to configure the MTU size for attached ENIs. The valid range is from 576 to 9001.
	//
	// Defaults to 9001.
	EniMtu pulumi.IntPtrInput
	// Specifies whether an external NAT gateway should be used to provide SNAT of secondary ENI IP addresses. If set to true, the SNAT iptables rule and off-VPC IP rule are not applied, and these rules are removed if they have already been applied.
	//
	// Defaults to false.
	ExternalSnat pulumi.BoolPtrInput
	// Specifies the file path used for logs.
	//
	// Defaults to "stdout" to emit Pod logs for `kubectl logs`.
	LogFile pulumi.StringPtrInput
	// Specifies the log level used for logs.
	//
	// Defaults to "DEBUG"
	// Valid values: "DEBUG", "INFO", "WARN", "ERROR", or "FATAL".
	LogLevel pulumi.StringPtrInput
	// Specifies whether NodePort services are enabled on a worker node's primary network interface. This requires additional iptables rules and that the kernel's reverse path filter on the primary interface is set to loose.
	//
	// Defaults to true.
	NodePortSupport pulumi.BoolPtrInput
	// How to resolve field value conflicts when migrating a self-managed add-on to an Amazon EKS add-on. Valid values are `NONE` and `OVERWRITE`. For more details see the [CreateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateAddon.html) API Docs.
	ResolveConflictsOnCreate *ResolveConflictsOnCreate
	// How to resolve field value conflicts for an Amazon EKS add-on if you've changed a value from the Amazon EKS default value.  Valid values are `NONE`, `OVERWRITE`, and `PRESERVE`. For more details see the [UpdateAddon](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html) API Docs.
	ResolveConflictsOnUpdate *ResolveConflictsOnUpdate
	// Pass privilege to containers securityContext. This is required when SELinux is enabled. This value will not be passed to the CNI config by default
	SecurityContextPrivileged pulumi.BoolPtrInput
	// The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role.
	//
	// For more information, see [Amazon EKS node IAM role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html) in the Amazon EKS User Guide.
	//
	// Note: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see [Enabling IAM roles for service accounts on your cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html) in the Amazon EKS User Guide.
	ServiceAccountRoleArn pulumi.StringPtrInput
	// Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapArrayInput
	// Specifies the veth prefix used to generate the host-side veth device name for the CNI.
	//
	// The prefix can be at most 4 characters long.
	//
	// Defaults to "eni".
	VethPrefix pulumi.StringPtrInput
	// Specifies the number of free elastic network interfaces (and all of their available IP addresses) that the ipamD daemon should attempt to keep available for pod assignment on the node.
	//
	// Defaults to 1.
	WarmEniTarget pulumi.IntPtrInput
	// Specifies the number of free IP addresses that the ipamD daemon should attempt to keep available for pod assignment on the node.
	WarmIpTarget pulumi.IntPtrInput
	// WARM_PREFIX_TARGET will allocate one full (/28) prefix even if a single IP  is consumed with the existing prefix. Ref: https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/prefix-and-ip-target.md
	WarmPrefixTarget pulumi.IntPtrInput
}

func (VpcCniAddonArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vpcCniAddonArgs)(nil)).Elem()
}

type VpcCniAddonInput interface {
	pulumi.Input

	ToVpcCniAddonOutput() VpcCniAddonOutput
	ToVpcCniAddonOutputWithContext(ctx context.Context) VpcCniAddonOutput
}

func (*VpcCniAddon) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniAddon)(nil)).Elem()
}

func (i *VpcCniAddon) ToVpcCniAddonOutput() VpcCniAddonOutput {
	return i.ToVpcCniAddonOutputWithContext(context.Background())
}

func (i *VpcCniAddon) ToVpcCniAddonOutputWithContext(ctx context.Context) VpcCniAddonOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniAddonOutput)
}

// VpcCniAddonArrayInput is an input type that accepts VpcCniAddonArray and VpcCniAddonArrayOutput values.
// You can construct a concrete instance of `VpcCniAddonArrayInput` via:
//
//	VpcCniAddonArray{ VpcCniAddonArgs{...} }
type VpcCniAddonArrayInput interface {
	pulumi.Input

	ToVpcCniAddonArrayOutput() VpcCniAddonArrayOutput
	ToVpcCniAddonArrayOutputWithContext(context.Context) VpcCniAddonArrayOutput
}

type VpcCniAddonArray []VpcCniAddonInput

func (VpcCniAddonArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VpcCniAddon)(nil)).Elem()
}

func (i VpcCniAddonArray) ToVpcCniAddonArrayOutput() VpcCniAddonArrayOutput {
	return i.ToVpcCniAddonArrayOutputWithContext(context.Background())
}

func (i VpcCniAddonArray) ToVpcCniAddonArrayOutputWithContext(ctx context.Context) VpcCniAddonArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniAddonArrayOutput)
}

// VpcCniAddonMapInput is an input type that accepts VpcCniAddonMap and VpcCniAddonMapOutput values.
// You can construct a concrete instance of `VpcCniAddonMapInput` via:
//
//	VpcCniAddonMap{ "key": VpcCniAddonArgs{...} }
type VpcCniAddonMapInput interface {
	pulumi.Input

	ToVpcCniAddonMapOutput() VpcCniAddonMapOutput
	ToVpcCniAddonMapOutputWithContext(context.Context) VpcCniAddonMapOutput
}

type VpcCniAddonMap map[string]VpcCniAddonInput

func (VpcCniAddonMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VpcCniAddon)(nil)).Elem()
}

func (i VpcCniAddonMap) ToVpcCniAddonMapOutput() VpcCniAddonMapOutput {
	return i.ToVpcCniAddonMapOutputWithContext(context.Background())
}

func (i VpcCniAddonMap) ToVpcCniAddonMapOutputWithContext(ctx context.Context) VpcCniAddonMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcCniAddonMapOutput)
}

type VpcCniAddonOutput struct{ *pulumi.OutputState }

func (VpcCniAddonOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcCniAddon)(nil)).Elem()
}

func (o VpcCniAddonOutput) ToVpcCniAddonOutput() VpcCniAddonOutput {
	return o
}

func (o VpcCniAddonOutput) ToVpcCniAddonOutputWithContext(ctx context.Context) VpcCniAddonOutput {
	return o
}

type VpcCniAddonArrayOutput struct{ *pulumi.OutputState }

func (VpcCniAddonArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VpcCniAddon)(nil)).Elem()
}

func (o VpcCniAddonArrayOutput) ToVpcCniAddonArrayOutput() VpcCniAddonArrayOutput {
	return o
}

func (o VpcCniAddonArrayOutput) ToVpcCniAddonArrayOutputWithContext(ctx context.Context) VpcCniAddonArrayOutput {
	return o
}

func (o VpcCniAddonArrayOutput) Index(i pulumi.IntInput) VpcCniAddonOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VpcCniAddon {
		return vs[0].([]*VpcCniAddon)[vs[1].(int)]
	}).(VpcCniAddonOutput)
}

type VpcCniAddonMapOutput struct{ *pulumi.OutputState }

func (VpcCniAddonMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VpcCniAddon)(nil)).Elem()
}

func (o VpcCniAddonMapOutput) ToVpcCniAddonMapOutput() VpcCniAddonMapOutput {
	return o
}

func (o VpcCniAddonMapOutput) ToVpcCniAddonMapOutputWithContext(ctx context.Context) VpcCniAddonMapOutput {
	return o
}

func (o VpcCniAddonMapOutput) MapIndex(k pulumi.StringInput) VpcCniAddonOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VpcCniAddon {
		return vs[0].(map[string]*VpcCniAddon)[vs[1].(string)]
	}).(VpcCniAddonOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniAddonInput)(nil)).Elem(), &VpcCniAddon{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniAddonArrayInput)(nil)).Elem(), VpcCniAddonArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcCniAddonMapInput)(nil)).Elem(), VpcCniAddonMap{})
	pulumi.RegisterOutputType(VpcCniAddonOutput{})
	pulumi.RegisterOutputType(VpcCniAddonArrayOutput{})
	pulumi.RegisterOutputType(VpcCniAddonMapOutput{})
}
