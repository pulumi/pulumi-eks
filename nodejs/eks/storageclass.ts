// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as aws from "@pulumi/aws";
import * as k8s from "@pulumi/kubernetes";
import * as k8sInputs from "@pulumi/kubernetes/types/input";
import * as pulumi from "@pulumi/pulumi";

/**
 * EBSVolumeType lists the set of volume types accepted by an EKS storage class.
 */
export type EBSVolumeType = "io1" | "gp2" | "gp3" | "sc1" | "st1";

/**
 * StorageClass describes the inputs to a single Kubernetes StorageClass provisioned by AWS. Any number of storage
 * classes can be added to a cluster at creation time. One of these storage classes may be configured the default
 * storage class for the cluster.
 */
export interface StorageClass {
    /**
     * The EBS volume type.
     */
    type: pulumi.Input<EBSVolumeType>;

    /**
     * The AWS zone or zones for the EBS volume. If zones is not specified, volumes are generally round-robin-ed across
     * all active zones where Kubernetes cluster has a node. zone and zones parameters must not be used at the same
     * time.
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;

    /**
     * I/O operations per second per GiB for "io1" volumes. The AWS volume plugin multiplies this with the size of a
     * requested volume to compute IOPS of the volume and caps the result at 20,000 IOPS.
     */
    iopsPerGb?: pulumi.Input<number>;

    /**
     * Denotes whether the EBS volume should be encrypted.
     */
    encrypted?: pulumi.Input<boolean>;

    /**
     * The full Amazon Resource Name of the key to use when encrypting the volume. If none is supplied but encrypted is
     * true, a key is generated by AWS.
     */
    kmsKeyId?: pulumi.Input<string>;

    /**
     * True if this storage class should be a default storage class for the cluster.
     *
     * Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will
     * always be created automatically for the cluster by the EKS service. See
     * https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
     *
     * Please note that at most one storage class can be marked as default. If
     * two or more of them are marked as default, a PersistentVolumeClaim
     * without `storageClassName` explicitly specified cannot be created. See:
     * https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/#changing-the-default-storageclass
     */
    default?: pulumi.Input<boolean>;

    /**
     * AllowVolumeExpansion shows whether the storage class allow volume expand
     */
    allowVolumeExpansion?: pulumi.Input<boolean>;

    /**
     * Standard object's metadata. More info:
     * https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     */
    metadata?: pulumi.Input<k8sInputs.meta.v1.ObjectMeta>;

    /**
     * Dynamically provisioned PersistentVolumes of this storage class are created with these
     * mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one
     * is invalid.
     */
    mountOptions?: pulumi.Input<string[]>;

    /**
     * Dynamically provisioned PersistentVolumes of this storage class are created with this
     * reclaimPolicy. Defaults to Delete.
     */
    reclaimPolicy?: pulumi.Input<string>;

    /**
     * VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
     * When unset, VolumeBindingImmediate is used. This field is alpha-level and is only honored
     * by servers that enable the VolumeScheduling feature.
     */
    volumeBindingMode?: pulumi.Input<string>;
}

/**
 * Creates a single Kubernetes StorageClass from the given inputs.
 */
export function createStorageClass(
    name: string,
    storageClass: StorageClass,
    opts: pulumi.CustomResourceOptions,
): k8s.storage.v1.StorageClass {
    // Compute the storage class's metadata, including its name and default storage class annotation.
    const metadata = pulumi
        .all([storageClass.metadata || {}, storageClass.default])
        .apply(([m, isDefault]) => {
            if (isDefault) {
                m.annotations = {
                    ...(m.annotations || {}),
                    "storageclass.kubernetes.io/is-default-class": "true",
                };
            }
            return m;
        });

    // Figure out the parameters for the storage class.
    const parameters: { [key: string]: pulumi.Input<string> } = {
        type: storageClass.type,
    };
    if (storageClass.zones) {
        parameters["zones"] = pulumi.output(storageClass.zones).apply((v) => v.join(", "));
    }
    if (storageClass.iopsPerGb) {
        parameters["iopsPerGb"] = pulumi.output(storageClass.iopsPerGb).apply((v) => `${v}`);
    }
    if (storageClass.encrypted) {
        parameters["encrypted"] = pulumi.output(storageClass.encrypted).apply((v) => `${v}`);
    }
    if (storageClass.kmsKeyId) {
        parameters["kmsKeyId"] = storageClass.kmsKeyId;
    }

    return new k8s.storage.v1.StorageClass(
        name,
        {
            metadata: metadata,
            provisioner: "kubernetes.io/aws-ebs",
            parameters: parameters,
            allowVolumeExpansion: storageClass.allowVolumeExpansion,
            mountOptions: storageClass.mountOptions,
            reclaimPolicy: storageClass.reclaimPolicy,
            volumeBindingMode: storageClass.volumeBindingMode,
        },
        opts,
    );
}
